if game:GetService("RunService"):IsClient() then error("Script must be server-side in order to work; use h/ and not hl/") end
local Player,Mouse,mouse,UserInputService,ContextActionService = owner
do
	print("FE Compatibility code by Mokiros | Translated to FE by iPxter")
	script.Parent = Player.Character

	--RemoteEvent for communicating
	local Event = Instance.new("RemoteEvent")
	Event.Name = "UserInput_Event"

	--Fake event to make stuff like Mouse.KeyDown work
	local function fakeEvent()
		local t = {_fakeEvent=true,Connect=function(self,f)self.Function=f end}
		t.connect = t.Connect
		return t
	end

	--Creating fake input objects with fake variables
	local m = {Target=nil,Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent()}
	local UIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent()}
	local CAS = {Actions={},BindAction=function(self,name,fun,touch,...)
		CAS.Actions[name] = fun and {Name=name,Function=fun,Keys={...}} or nil
	end}
	--Merged 2 functions into one by checking amount of arguments
	CAS.UnbindAction = CAS.BindAction

	--This function will trigger the events that have been :Connect()'ed
	local function te(self,ev,...)
		local t = m[ev]
		if t and t._fakeEvent and t.Function then
			t.Function(...)
		end
	end
	m.TrigEvent = te
	UIS.TrigEvent = te

	Event.OnServerEvent:Connect(function(plr,io)
		if plr~=Player then return end
		if io.isMouse then
			m.Target = io.Target
			m.Hit = io.Hit
		else
			local b = io.UserInputState == Enum.UserInputState.Begin
			if io.UserInputType == Enum.UserInputType.MouseButton1 then
				return m:TrigEvent(b and "Button1Down" or "Button1Up")
			end
			for _,t in pairs(CAS.Actions) do
				for _,k in pairs(t.Keys) do
					if k==io.KeyCode then
						t.Function(t.Name,io.UserInputState,io)
					end
				end
			end
			m:TrigEvent(b and "KeyDown" or "KeyUp",io.KeyCode.Name:lower())
			UIS:TrigEvent(b and "InputBegan" or "InputEnded",io,false)
		end
	end)
	Event.Parent = NLS([==[
	local Player = game:GetService("Players").LocalPlayer
	local Event = script:WaitForChild("UserInput_Event")

	local UIS = game:GetService("UserInputService")
	local input = function(io,a)
		if a then return end
		--Since InputObject is a client-side instance, we create and pass table instead
		Event:FireServer({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState})
	end
	UIS.InputBegan:Connect(input)
	UIS.InputEnded:Connect(input)

	local Mouse = Player:GetMouse()
	local h,t
	--Give the server mouse data 30 times every second, but only if the values changed
	--If player is not moving their mouse, client won't fire events
	while wait(1/30) do
		if h~=Mouse.Hit or t~=Mouse.Target then
			h,t=Mouse.Hit,Mouse.Target
			Event:FireServer({isMouse=true,Target=t,Hit=h})
		end
	end]==],Player.Character)
	Mouse,mouse,UserInputService,ContextActionService = m,m,UIS,CAS
end
function randomstring()
	local e = {}
	for i = 1,math.random(1,10) do
		table.insert(e,#e+1,utf8.char(math.random(0,10175)))
	end
	return table.concat(e)
end
local Character = Player.Character
local cn,euler,rad,random,c3,v3,clamp,sin,cos = CFrame.new,CFrame.fromEulerAnglesYXZ,math.rad,math.random,Color3.fromRGB,Vector3.new,math.clamp,math.sin,math.cos
local hc0,lac0,rac0,llc0,rlc0,sine,animspeed,attack,keys,poscframe,ypos,yvelo,raycastparams,changingsoundvolume,partexclusion,gay,songid,loudnerd,firstperson,moving,velocity = cn(0,1.5,0),cn(-1.5,0,0),cn(1.5,0,0),cn(-0.5,-2,0),cn(0.5,-2,0),0,0.8/4,false,{w=false,a=false,s=false,d=false,space=false},CFrame.new() or cn(),50,0,RaycastParams.new(),false,{},"angry",5551904754,false,false,false,v3()
script.Name = randomstring()
game:GetService("RunService").Heartbeat:Wait()
local other = false
local ScriptSignals = {}
local speak = false
local unfairtables = false
local plrs,run,insert,rf,debris,workspace,ts,uis,pps = game:GetService("Players"),game:GetService("RunService"),game:GetService("ProximityPromptService"),game:GetService("ReplicatedFirst"),{},workspace,game:GetService("TweenService"),game:GetService("UserInputService"),game:GetService("ProximityPromptService")
rf:RemoveDefaultLoadingScreen()
local localplayer,username = Player,Player.Name
local userid,localuserid,funnyworld = Player.UserId,localplayer.UserId,Instance.new("WorldModel",workspace.CurrentCamera)
local c,gun,gunm,face
local r,h,t,la,ra,ll,rl = Character.HumanoidRootPart,Character.Head,Character.Torso,Character["Left Arm"],Character["Right Arm"],Character["Left Leg"],Character["Right Leg"]
local hoffset,toffset,laoffset,raoffset,lloffset,rloffset,gunoffset = hc0,cn(),lac0,rac0,llc0,rlc0,cn(-0.125,-0.898999929,0.95400238)*euler(0,rad(90),rad(-172.5))
raycastparams.FilterType,raycastparams.IgnoreWater = Enum.RaycastFilterType.Blacklist,true
local Meshs
local hicolor
local cam = workspace.CurrentCamera
local camerapos = nil
local Materials = {"Brick","Cobblestone","Concrete","Fabric","Granite","Grass","Glass","Marble","Neon","Pebble","Plastic","Sand","SmoothPlastic","Slate","Wood","WoodPlanks"}
function tween(instance,properties,duration,easingdirection,easingstyle)
	pcall(function()
		if easingstyle == nil then easingstyle = Enum.EasingStyle.Quad end
		ts:Create(instance,TweenInfo.new(duration,easingstyle,easingdirection),properties):Play()
	end)	
end
function debris.AddItem(item,teim)
	coroutine.resume(coroutine.create(function()
		wait(teim)
		if item then
			item:Destroy()
		end
	end))
end
local Parents3 = {"Workspace","SoundService","Chat","MarketplaceService","Players","StarterPlayer","LocalizationService","JointsService","FriendService","InsertService","Lighting","Teams","ReplicatedStorage","TestService","ProximityPromptService","RunService","Debris","StarterGui","StarterPlayer"}
local StudioDum
local Wowie
local Fly
local ActiveFly
local FlyDown
local FlyUp
local Attack
local LoudMode
local ActiveLoud
local Types
local Types_2
local Mode
local HeartUndertale
local Attack_2

funnyworld.Name = randomstring()
function change(instance,properties)
	for i, v in next, properties do
		instance[i] = v
	end
end
function create(class,properties)
	local instance = Instance.new(class)
	instance.Name = randomstring()
	change(instance,properties)
	return instance
end
local modes = nil

function gettransparency(transparency)
	if firstperson then
		return 1
	else
		return transparency
	end
end



function Swait(num)
	if num == 0 or num == nil then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i = 1, num do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
swait = Swait
function newmode(howtouseindexlol)
	gay = howtouseindexlol
end
run.Heartbeat:Connect(function()
	if funnyworld.Parent ~= workspace.Terrain or funnyworld.Archivable ~= false then
		funnyworld = Instance.new("WorldModel")
		funnyworld.Parent = workspace.Terrain
		funnyworld.Name = randomstring()
		funnyworld.Archivable = false
	end
	if not Effects or Effects.Parent ~= workspace.Terrain or Effects.Archivable ~= false then
		Effects = Instance.new("WorldModel")
		Effects.Parent = workspace.Terrain
		Effects.Name = randomstring()
		Effects.Archivable = false
	end
	if not c or c.Parent ~= funnyworld or c.Transparency ~= 1 or c.CastShadow or not c.Anchored or c.CanCollide or c.Archivable or not c.Locked then
		if table.find(partexclusion,c) then
			table.remove(partexclusion,table.find(partexclusion,c))
		end
		c = Instance.new("Part")
		c.Transparency = 1
		c.Name = randomstring()
		c.CanCollide = false
		c.Anchored = true
		c.CanTouch = false
		c.Locked = true
		c.CastShadow = false
		c.Parent = funnyworld
		c.Archivable = false
	end
	if not gun or gun.Parent ~= funnyworld or gun.Transparency ~= 0 or gun.LocalTransparencyModifier ~= 0 or gun.CastShadow or not gun.Anchored or gun.CanCollide or gun.Archivable or not gun.Locked then
		gun = Instance.new("Part"):Clone()
		gun.Material = "Neon"
		gun.Color = Color3.new(1,1,1)
		gun.CFrame = ra.CFrame*gunoffset
		gun.CanCollide = false
		gunlight = Instance.new("PointLight")
		gunlight.Parent = gun
		gunlight.Range = 6
		gunlight.Brightness = 7.06
		gun.Transparency = 0
		gun.Name = randomstring()
		gun.Anchored = true
		gun.CanTouch = false
		gun.CastShadow = false
		gun.Locked = true
		gun.Archivable = false
		gun.Parent = funnyworld
	end
	if not gunm or gunm.Parent ~= gun then
		gunm = Instance.new("SpecialMesh")
		gunm.TextureId = "rbxassetid://55260662"
		gunm.MeshId = "rbxassetid://1736736188"
		gunm.VertexColor = Vector3.new(255,255,255)
		gunm.Parent = gun
		gunm.Archivable = false
		gunm.Name = randomstring()
	end
	if r.CFrame.X >= 3000 or r.CFrame.Y >= 3000 or r.CFrame.Z >= 3000 or r.CFrame.X <= -3000 or r.CFrame.Y <= -3000 or r.CFrame.Z <= -3000 then
		respawnchr()
	end
end)
function CreateMesh(MESH,PARENT,MESHTYPE,MESHID,TEXTUREID,SCALE,OFFSET)
	local NEWMESH = Instance.new(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" and tonumber(MESHID) ~= nil then
			NEWMESH.MeshId = "rbxassetid://"..MESHID
		elseif MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "rbxassetid://"..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or Vector3.new()
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end
local NEWSOUND
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	NEWSOUND = Instance.new("Sound")
	NEWSOUND.Parent = PARENT
	NEWSOUND.Volume = VOLUME
	NEWSOUND.Pitch = PITCH
	NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
	NEWSOUND.Looped = DOESLOOP
	NEWSOUND:play()
	return NEWSOUND
end
local NEWPART
function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	NEWPART = Instance.new("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
local CameraZoom = 1
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or r.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or hicolor)
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	if sOK > .1 then
		RAINBOWPART = true
	end
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local posC = (Table.posC or nil)
	local oriC = (Table.oriC or nil)
	local SizeC = (Table.SizeC or Vector3.new(0,0,0))
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3,Effects,MATERIAL,0,TRANSPARENCY,hicolor,randomstring(),Vector3.new(1,1,1),true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = Vector3.new(SIZE.X,SIZE.Y,SIZE.Z)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","1051557","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			EFFECT.CFrame = CFRAME
			if SizeC then
				MSH.Scale = MSH.Scale+SizeC*(0.01*TIME)
			end
			for LOOP = 1,TIME+1 do
				swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = Vector3.new(0,0,-MSH.Scale.X/8)
				end
				if oriC and posC then
					EFFECT.CFrame = EFFECT.CFrame * (posC * oriC)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				EFFECT:Destroy()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				EFFECT:Destroy()
			end
		end
	end))
end

function respawnchr()
	for i, v in next, workspace:GetDescendants() do
		r.CFrame,c.CFrame,poscframe,ypos = cn(1,50,1),cn(1,50,1),cn(1,50,1),50	
	end
end
local attacks = {}
local ws = 0.2
local deathlist = {}
local Remotes = {}
local Size,Material,Trans,CanC,Anchored,Colora,ParentClass,ClassName = {},{},{},{},{},{},{},{}
local anthornonimporttancestuff = {"SoundService","Chat","MarketplaceService","Players","StarterPlayer","LocalizationService","JointsService","FriendService","InsertService","Lighting","Teams","ReplicatedStorage","TestService","ProximityPromptService"}
local cbtcockandballtorture = {}
local Parents = {"Workspace","SoundService","Chat","MarketplaceService","Players","StarterPlayer","LocalizationService","JointsService","FriendService","InsertService","Lighting","Teams","ReplicatedStorage","TestService","ProximityPromptService","RunService","Debris","StarterGui","StarterPlayer"}
local Parents2 = {"Workspace","SoundService","Chat","MarketplaceService","Players","StarterPlayer","LocalizationService","JointsService","FriendService","InsertService","Lighting","Teams","ReplicatedStorage","TestService","ProximityPromptService","RunService","Debris","StarterGui","StarterPlayer"}
local InstanceCount = 0
task.wait(0.3)
function onFuckingChatted(msg)
	if msg:sub(1,9) == "/e end/" or msg:sub(1,9) == "/e death/" then
		script:Destroy()
		Player:LoadCharacter()
	end
end
function attacks:loldiepart(p)
	if p:IsDescendantOf(funnyworld) or p:IsDescendantOf(Effects) then return end
	table.insert(partexclusion,p)
	local e = create("Part",{
		Parent = Effects,
		CanCollide = false,
		Color = hicolor,
		CFrame = p.CFrame,
		Size = p.Size,
		Material = Enum.Material.Neon,
		Velocity = v3(random(-30,30),30,random(-30,30)),
		RotVelocity = v3(random(-15,15),random(-15,15),random(-15,15))
	})
	table.insert(partexclusion,e)
	local dur = math.random(1, 2)
	local dur2 = math.random(72, 472)/300
	if dur <= 1 then
		dur = math.random(1, 2)
	end
	tween(e,{Transparency=1},dur2,Enum.EasingDirection.In,Enum.EasingStyle.Linear)
	coroutine.resume(coroutine.create(function()
		wait(dur)
		e:Destroy()
	end))
end

local Ignored = {}
function Find(Table,Value)
	for i,g in pairs(Table) do
		if g == Value then
			return g
		end
	end
end
function Clerp(a,b,t)
	return a:Lerp(b,t)
end
local inf = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368
local bgm,bgmstartime,bgmtimelength,bgmeffect,bgmloud,bgmeffectloud,bgmloudloud = create("Sound",{Parent=game:GetService("AdService")}),tick(),68.555,Instance.new("EqualizerSoundEffect"),nil,nil,nil
local bgmremoved = game:GetService("AdService").ChildRemoved:Connect(function(instance)
	bgmeffect.Parent = bgm
	if instance == bgm then
		bgm = create("Sound",{Parent=game:GetService("AdService")})
		sick = bgm
		bgmeffect = create("EqualizerSoundEffect",{Parent=bgm})
		bgmeffect.HighGain = 7.3
		bgmeffect.LowGain = -0.8
		bgmeffect.MidGain = 4.3
		local bober = nil
		bober = bgm.DescendantAdded:connect(function(hi)
			if hi:IsA("TremoloSoundEffect") then
				run.Heartbeat:Connect(function()
					hi.Duty = 1
				end)
				hi.Enabled = false
				hi:GetPropertyChangedSignal("Enabled"):Connect(function()
					if hi.Enabled ~= false then
						hi.Enabled = false
					end
				end)
			end
			wait(0.01)
			hi:Destroy()
		end)
		local diff = tick()-bgmstartime
		change(bgm,{
			SoundId = "rbxassetid://"..songid,
			Looped = true,
			Name = randomstring(),
			Pitch = 1,
			Playing = true,
			RollOffMaxDistance = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368,
			RollOffMinDistance = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368,
			RollOffMode = Enum.RollOffMode.Inverse,
			TimePosition = clamp(bgm.TimePosition,diff-0.2,diff+0.2),
			Archivable = false,
			PlayOnRemove = false
		})
		bgm.SoundGroup = nil
	end
end)

hicolor = Color3.fromRGB(255,140,140)
function attacks:hitbox(radius,pos)
	for i=1,#Parents do
		for i,v in pairs(game:GetService(Parents[i]):GetDescendants()) do
			if not v:IsDescendantOf(Character) and v.Parent ~= Character and v ~= gun and v ~= c then
				local p = v
				if v:IsA("BasePart") and v.Name ~= "Baseplate" and not v:IsA("Terrain") and v.Name ~= "Base" and (v.Position - pos).Magnitude <= radius + v.Size.Magnitude then			
					table.insert(Size,p.Size)
					table.insert(Material,p.Material)
					table.insert(Trans,p.Transparency)
					table.insert(CanC,p.CanCollide)
					table.insert(Anchored,p.Anchored)
					table.insert(Colora,p.Color)
					table.insert(ClassName,p.ClassName)
					v.CFrame = CFrame.new(0,1e6,0)
					v.Anchored = true
					v.Changed:Connect(function()
						v.Anchored = true
						v.CFrame = CFrame.new(0,1e6,0) 
					end)
				end
				if v:IsA("FlagStand") and v.Name ~= "Baseplate" and not v:IsA("Terrain") and v.Name ~= "Base" and (v.Position - pos).Magnitude <= radius + v.Size.Magnitude then				
					table.insert(Size,p.Size)
					table.insert(Material,p.Material)
					table.insert(Trans,p.Transparency)
					table.insert(CanC,p.CanCollide)
					table.insert(Anchored,p.Anchored)
					table.insert(Colora,p.Color)
					table.insert(ClassName,p.ClassName)
					v.CFrame = CFrame.new(0,1e6,0)
					v.Anchored = true
					v.Changed:Connect(function()
						v.Anchored = true
						v.CFrame = CFrame.new(0,1e6,0) 
					end)
				end
			end
		end
	end
end	

function attacks:pew(pos)
	local wssaved = ws
	attack,ws = true,0.05
	for i = 1, 3, 0.1 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(0.0649986267,0,0.240997314)*euler(rad(-7.5),rad(15),0),0.3/3)
		raoffset = raoffset:Lerp(rac0*cn(0.0480003357,0.375,-0.614997864)*euler(rad(90),rad(-22.5),0),0.3/3)
		lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),0.3/3)
		rloffset = rloffset:Lerp(rlc0,0.3/3)
		toffset = toffset:Lerp(euler(0,rad(22.5),0),0.3/3)
		hoffset = hoffset:Lerp(hc0*euler(0,rad(-22.5),0),0.3/3)
		gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),0.3/3)
	end
	local start = (gun.CFrame * cn(3.43700027,0.504000008,0.00199890137)).p
	debris:AddItem(create("Sound",{
		Parent = gun,
		SoundId = "rbxassetid://3723700663",
		Playing = true,
		Volume = 3,
		PlayOnRemove = true
	}),0)
	local bruurubu = create("Part",{
		Parent = Effects,
		Anchored = true,
		Color = hicolor,
		CanCollide = false,
		Material = Enum.Material.Neon,
		Size = v3(1.5,1.5,1.5),
		CFrame = cn(start) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
	})
	table.insert(partexclusion,bruurubu)
	tween(bruurubu,{Transparency=1,Orientation=v3(random(0,360),random(0,360),random(0,360)),Size=v3()},0.2,Enum.EasingDirection.In)
	debris:AddItem(bruurubu,0.2)
	for i = 1, 5 do
		local function dosomethingidk()
			raycastparams.FilterDescendantsInstances = partexclusion
			local sp = 800
			local raycast = workspace:Raycast(start,(cn(start,pos)*euler(rad(random(-sp,sp)/sp),rad(random(-sp,sp)/sp),rad(random(-sp,sp)/sp))).LookVector*2048,raycastparams)
			if raycast then
				return raycast.Position
			else
				return (cn(start)*cn(start,pos)*cn(0,0,-2048)).p
			end
		end
		local hitpos = dosomethingidk()
		local length = clamp((start-hitpos).Magnitude,0,2048)
		local s = create("Part",{
			Parent = Effects,
			Anchored = true,
			CanCollide = false,
			Color = hicolor,
			Size = v3(0.5,0.5,length),
			Material = Enum.Material.Neon,
			Position = start,
			CFrame = cn(start,hitpos)
		})
		table.insert(partexclusion,s)
		s.CFrame = s.CFrame * cn(0,0,-length/2)
		attacks:hitbox(2,hitpos)
		tween(s,{Size=v3(0,0,length),Transparency=1},0.2,Enum.EasingDirection.In)
		debris:AddItem(s,0.2)
		local hiteffectidk = create("Part",{
			Parent = Effects,
			Anchored = true,
			Color = hicolor,
			CanCollide = false,
			Material = Enum.Material.Neon,
			Size = v3(1.5,1.5,1.5),
			CFrame = cn(hitpos) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
		})
		table.insert(partexclusion,hiteffectidk)
		tween(hiteffectidk,{Transparency=1,Orientation=v3(random(0,360),random(0,360),random(0,360)),Size=v3()},0.2,Enum.EasingDirection.In)
		debris:AddItem(hiteffectidk,0.2)
		local shock = Instance.new("Part")
		change(shock,{
			Parent = Effects,
			Anchored = true,
			Color = hicolor,
			CanCollide = false,
			Size = v3(0.1,0.1,0.1),
			Material = Enum.Material.Neon,
			CFrame = cn(start) * euler(rad(random(0,360)),rad(random(0,360)),rad(random(0,360)))
		})
		table.insert(partexclusion,shock)
		tween(shock,{Size=v3(0.1,random(5,7),0.1),Transparency=1},random(5,15)/30,Enum.EasingDirection.Out)
		debris:AddItem(shock,0.5)
	end
	for i = 1, 3, 0.1 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(-0.0429992676,0.0380001068,-0.700996399)*euler(rad(60),rad(15),rad(-7.5)),0.3/2)
		raoffset = raoffset:Lerp(rac0*cn(-0.39799881,0.246000051,-0.800003052)*euler(rad(75),rad(67.5),0),0.3/2)
		lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),0.3/2)
		rloffset = rloffset:Lerp(rlc0,0.3/2)
		toffset = toffset:Lerp(euler(0,rad(22.5),0),0.3/2)
		hoffset = hoffset:Lerp(hc0*cn(-0.016998291,-0.0170001984,-0.126998901)*euler(rad(-14.74),rad(15.39),rad(-2)),0.3/2)
		gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),0.3/2)
	end
	for i = 1, 2, 0.15 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(0.199001312,0.0780000687,-0.694999695)*euler(rad(60),rad(15),rad(30)),0.3/2*2)
		raoffset = raoffset:Lerp(rac0*cn(-0.39799881,0.246000051,-0.800003052)*euler(rad(75),rad(67.5),0),0.3/2*2)
		lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),0.3/2*2)
		rloffset = rloffset:Lerp(rlc0,0.3/2*2)
		toffset = toffset:Lerp(euler(0,rad(22.5),0),0.3/2*2)
		hoffset = hoffset:Lerp(hc0*cn(-0.016998291,-0.0170001984,-0.126998901)*euler(rad(-14.74),rad(15.39),rad(-2)),0.3/2*2)
		gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),0.3/2*2)
	end
	for i = 1, 2, 0.1 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(-0.0429992676,0.0380001068,-0.700996399)*euler(rad(60),rad(15),rad(-7.5)),0.3/2)
		raoffset = raoffset:Lerp(rac0*cn(-0.39799881,0.246000051,-0.800003052)*euler(rad(75),rad(67.5),0),0.3/2)
		lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),0.3/2)
		rloffset = rloffset:Lerp(rlc0,0.3/2)
		toffset = toffset:Lerp(euler(0,rad(22.5),0),0.3/2)
		hoffset = hoffset:Lerp(hc0*cn(-0.016998291,-0.0170001984,-0.126998901)*euler(rad(-14.74),rad(15.39),rad(-2)),0.3/2)
		gunoffset = gunoffset:Lerp(cn(-0.25,-1.52400005,-0.2970047)*euler(0,rad(90),rad(-90)),0.3/2)
	end
	attack,ws = false,wssaved
end
function attacks:ouch(pos)
	local wssaved = ws
	attack,ws = true,0.05
	for i = 0.2, 4, 0.15 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(0.0649986267,0,0.240997314)*euler(rad(-7.5),rad(15),0),0.2/2)
		raoffset = raoffset:Lerp(rac0*cn(-0.701998138,0.35999999,-0.476997375)*euler(rad(-180),rad(-190),rad(95)),0.2/2)
		lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),0.2/2)
		rloffset = rloffset:Lerp(rlc0*cn(0,0,-0.5),0.2/2)
		toffset = toffset:Lerp(euler(0,rad(30),0),0.2/2)
		hoffset = hoffset:Lerp(hc0*euler(0,rad(30),0),0.2/2)
		gunoffset = gunoffset:Lerp(cn(0.116001129,-2.6,-0.424999237)*euler(rad(0.06),rad(98),rad(75.06)),0.2/2)
	end
	attacks:hitbox(4,pos)
	debris:AddItem(create("Sound",{
		Parent = gun,
		SoundId = "http://www.roblox.com/asset/?id=12222208",
		Volume = 2,
		Playing = true,
		PlayOnRemove = true
	}),0)
	for i = 0.005, 3, 0.1 do
		swait()
		laoffset = laoffset:Lerp(lac0*cn(0.0649986267,0,0.240997314)*euler(rad(-7.5),rad(30),0),0.2/4)
		raoffset = raoffset:Lerp(rac0*cn(0.501998138,0.35999999,-0.676997375)*euler(rad(-180),rad(380),rad(95)),0.2/4)
		lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),0.2/4)
		rloffset = rloffset:Lerp(rlc0*cn(0,0,-0.5),0.2/4)
		toffset = toffset:Lerp(euler(0,rad(-30),0),0.2/4)
		hoffset = hoffset:Lerp(hc0*euler(0,rad(-30),0),0.2/4)
		gunoffset = gunoffset:Lerp(cn(0.116001129,-2.6,-0.424999237)*euler(rad(0.06),rad(90),rad(75.06)),0.2/4)
	end
	attack,ws = false,wssaved
end
local PartsTables = {"CornerWedgePart","Part","FlagStand","WedgePart"}
local ohwow = 1
function attacks:tp(pos)
	local oldpos = poscframe.p
	local _pos = {oldpos,pos}
	poscframe,ypos = cn(pos),pos.Y
	for i = 1, 2 do
		local b = create(PartsTables[math.random(#PartsTables)],{
			Parent = Effects,
			Anchored = true,
			CanCollide = false,
			Color = c3(math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048)),
			Material = Materials[math.random(#Materials)],
			Size = v3(math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048)),
			Position = _pos[i],
		})
		table.insert(Ignored,b)
		local bsuka = create("SpecialMesh",{
			Parent = b,
			MeshType = "FileMesh",
			TextureId = "rbxassetid://408737564",
			VertexColor = v3(255, 255, 255),
			Scale = v3(7,7,7)
		})
		table.insert(partexclusion,b)
		tween(b,{Size=v3(),Transparency=1},0.3,Enum.EasingDirection.In)
		debris:AddItem(b,0.3)
		tween(bsuka,{Scale=v3()},0.3,Enum.EasingDirection.In)
		debris:AddItem(bsuka,0.3)
	end
	local length = clamp((oldpos-pos).Magnitude,0,2048)
	local c = create(PartsTables[math.random(#PartsTables)],{
		Parent = Effects,
		Anchored = true,
		CanCollide = false,
		Color = c3(math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048)),
		Material = Materials[math.random(#Materials)],
		Size = v3(math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048), math.clamp(math.random(0.001,2048),0.01,2048)),
		Position = oldpos,
		CFrame = cn(oldpos) * cn(oldpos,pos)
	})
	table.insert(Ignored,c)
	local csuka = create("SpecialMesh",{
		Parent = c,
		MeshType = "FileMesh",
		TextureId = "rbxassetid://408737564",
		VertexColor = v3(255, 255, 255),
		Scale = v3(2,2,length)
	})
	table.insert(partexclusion,c)
	c.CFrame = c.CFrame * cn(0,0,-length/2)
	tween(c,{Size=v3(0,0,length),Transparency=1},0.3,Enum.EasingDirection.In)
	debris:AddItem(c,0.3)
	tween(csuka,{Scale=v3(0,0,length)},0.3,Enum.EasingDirection.In)
	debris:AddItem(csuka,0.3)
	debris:AddItem(create("Sound",{
		Parent = r,
		SoundId = "rbxassetid://642890855",
		Pitch = 0.45,
		Playing = true,
		PlayOnRemove = true
	}),0)
end

local fun = {}
local hold = false
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
fly = false
local rotationvalue = nil
run.Heartbeat:Connect(function()
	camerapos = poscframe
	if not r or not c then return end
	if not rotationvalue or rotationvalue.Parent ~= script then
		rotationvalue = Instance.new("CFrameValue",script)
		rotationvalue.Name = randomstring()
	end
	for _,v in pairs(Character:GetDescendants()) do
		if not table.find(partexclusion,v) then
			table.insert(partexclusion,v)
		end
	end
	r.Anchored,t.Anchored,h.Anchored,ra.Anchored,la.Anchored,rl.Anchored,ll.Anchored = true,true,true,true,true,true,true
	raycastparams.FilterDescendantsInstances = partexclusion
	local movedirection,lv,pos = v3(),cam.CFrame.LookVector,poscframe.p
	if keys.w then movedirection = movedirection + v3(0,0,-ws) end
	if keys.a then movedirection = movedirection + v3(-ws,0,0) end
	if keys.s then movedirection = movedirection + v3(0,0,ws) end
	if keys.d then movedirection = movedirection + v3(ws,0,0) end
	cam.CameraType = Enum.CameraType.Custom
	cam.CameraSubject = c
	if cam.HeadScale >= 1 then
		cam.HeadScale = 0
	end
	local cf = cam.CFrame
	local cfx,cfy,cfz = cf.X,cf.Y,cf.Z
	if cfx>= 3000 or cfy>= 3000 or cfz>= 3000 then 
		wait(0.1)
		cam:Destroy()
	end
	if cam.CameraType ~= Enum.CameraType.Custom then
		cam.CameraType = "Custom"
	end
	cam.HeadLocked = false
	cam.FieldOfView = 70
	local potentialposraycast,currentposraycast = workspace:Raycast(pos+movedirection,v3(0,-3.5,0),raycastparams),workspace:Raycast(pos,v3(0,-3.5,0),raycastparams)
	if currentposraycast and not fly then
		if keys.space then
			yvelo,ypos = 1.5,ypos+1.5
		elseif potentialposraycast then
			ypos,yvelo = potentialposraycast.Position.Y + 3,0
		end
	elseif fly then
		poscframe = cn(poscframe.p,poscframe.p+cam.CFrame.LookVector)
		poscframe = poscframe * cn(movedirection)
		ypos = poscframe.p.Y	
	elseif not fly then
		yvelo = clamp(yvelo-0.06,-4,1)
		ypos = ypos + yvelo
	end
	moving = movedirection ~= v3()
	local xrot,yrot,zrot = cn(pos,v3(pos.X+lv.X,pos.Y,pos.Z+lv.Z)):ToOrientation()
	local moveto = (cn(pos.X,ypos,pos.Z) * euler(0,yrot,0) * cn(movedirection)).p
	local xrot2,yrot2,zrot2 = cn(pos,moveto):ToOrientation()
	if uis.MouseBehavior == Enum.MouseBehavior.LockCenter then
		rotationvalue.Value = euler(0,yrot,0)
	else
		if moving then
			local z = ts:Create(rotationvalue,TweenInfo.new(0.15,Enum.EasingStyle.Linear,Enum.EasingDirection.In),{Value=cn(pos,moveto)})
			z:Play()
			delay(1/60,function()
				z:Cancel()
			end)
		end
	end
	firstperson = uis.MouseBehavior == Enum.MouseBehavior.LockCenter and (cam.CFrame.p-h.Position).Magnitude < 1
	local xrot3,yrot3,zrot3 = rotationvalue.Value:ToOrientation()
	velocity = (moveto-pos)*50
	poscframe = cn(moveto) * euler(0,yrot3,0)
	for _,v in pairs(Character:GetDescendants()) do
		if v:IsA("Shirt") or v:IsA("Pants") then
			v.Color3 = hicolor
		end
	end
	if not Character:FindFirstChildOfClass("ForceField") then
		local ff = Instance.new("ForceField",Character)
		ff.Visible = false
	end
	local Shield,actives
	if not workspace:FindFirstChild("ShieldMOmentobruh") then
		Shield = Instance.new("Part",workspace)
		Shield.Size = Vector3.new(6,6,6)
		Shield.CanCollide = false
		Shield.Anchored = true
		Shield.Name = "ShieldMOmentobruh"
		actives = true
	end
	if actives then
		Shield.CFrame = r.CFrame
	end
end)
local shiftdown = false
local keysupport = {
	[false] = {
		["space"] = " ",
		["leftbracket"] = "[",
		["rightbracket"] = "]",
		["minus"] = "-",
		["equals"] = "=",
		["period"] = ".",
		["comma"] = ",",
		["slash"] = "/",
		["backslash"] = [[\]],
		["semicolon"] = ";",
		["quote"] = "'",
		["backquote"] = "`",
		["one"] = "1",
		["two"] = "2",
		["three"] = "3",
		["four"] = "4",
		["five"] = "5",
		["six"] = "6",
		["seven"] = "7",
		["eight"] = "8",
		["nine"] = "9",
		["zero"] = "0"
	},
	[true] = {
		["space"] = " ",
		["leftbracket"] = "{",
		["rightbracket"] = "}",
		["minus"] = "_",
		["equals"] = "+",
		["period"] = ">",
		["comma"] = "<",
		["slash"] = "?",
		["backslash"] = "|",
		["semicolon"] = ":",
		["backquote"] = "~",
		["quote"] = '"',
		["one"] = "!",
		["two"] = "@",
		["three"] = "#",
		["four"] = "4",
		["five"] = "%",
		["six"] = "^",
		["seven"] = "&",
		["eight"] = "*",
		["nine"] = "(",
		["zero"] = ")"
	}
}
uis.InputBegan:Connect(function(a,gp)
	local key = string.lower(string.split(tostring(a.KeyCode),".")[3])
	if key == "leftshift" then
		shiftdown = true
	end
end)
uis.InputEnded:Connect(function(a)
	local key = string.lower(string.split(tostring(a.KeyCode),".")[3])
	if key == "leftshift" then
		shiftdown = false
	end
end)
Mouse.KeyDown:Connect(function(key)
	if not speak then
		if key == "w" or key == "a" or key == "s" or key == "d" then
			keys[key] = true
		elseif key == " " then
			keys.space = true
		elseif key == "e" then
			if not attack then
				local pos = (r.CFrame * cn(0,-2,-2)).p
				attacks:ouch(pos)
			end
		elseif key == "y" then
			unfairtables = not unfairtables
		elseif key == "f" then
			fly = not fly
			pcall(function()
				if fly then
					ActiveFly.Text = "Actived: true"
				elseif not fly then
					ActiveFly.Text = "Actived: false"
				end
			end)
		elseif key == "n" then
			Size = {}
			Material = {}
			Trans = {}
			CanC = {}
			Anchored = {}
			Colora = {}
			ParentClass = {}
			ClassName = {}
		elseif key == "m" then
			attacks:modehandler()
		elseif key == "z" then
			local pos = Mouse.Hit.p+v3(0,3,0)
			attacks:tp(pos)
		end
	end
end)
if localplayer.Name == username then
	if plrs[username] then
		plrs[username].Chatted:Connect(onFuckingChatted)
	end
end
Mouse.KeyUp:Connect(function(key)
	hold = false
	if key == "w" or key == "a" or key == "s" or key == "d" then
		keys[key] = false
	elseif key == " " then
		keys.space = false
	end
end)
Mouse.Button1Down:Connect(function()
	if not attack then
		local mousepos = Mouse.Hit.p
		attacks:pew(mousepos)
	end
end)
local services = {"RunService","GuiService","Stats","SoundService","LogService","ContentProvider","KeyframeSequenceProvider","Chat","MarketplaceService","Players","PointsService","AdService","NotificationService","ReplicatedFirst","HttpRbxApiService","TweenService","TextService","StarterPlayer","StarterPack","StarterGui","LocalizationService","PolicyService","TeleportService","JointsService","CollectionService","PhysicsService","BadgeService","Geometry","FriendService","InsertService","GamePassService","Debris","TimerService","CookiesService","UserInputService","KeyboardService","MouseService","VRService","ContextActionService","ScriptService","AssetService","TouchInputService","BrowserService","AnalyticsService","ScriptContext","Selection","HttpService","MeshContentProvider","Lighting","SolidModelContentProvider","GamepadService","ControllerService","RuntimeScriptService","HapticService","NetworkClient","ChangeHistoryService","Visit","GuidRegistryService","PermissionsService","Teams","ReplicatedStorage","TestService","SocialService","MemStorageService","GroupService","PathfindingService","VirtualUser"}

function attacks:modehandler()
	if gay == "hi" then
		newmode("angry")
		attack = true
		hicolor = Color3.fromRGB(255,140,140)
		ws = 0.2
		songid = 5551904754
		attack = false
		change(bgm,{SoundId = "rbxassetid://5551904754",Pitch = 1,Looped = true,TimePosition = 0})
	elseif gay == "angry" then
		attack = true
		newmode("ohfuck")
		hicolor = Color3.fromRGB(50,100,200)
		songid = 5326818596
		attack = false
		change(bgm,{SoundId = "rbxassetid://5326818596",Pitch = 1,Looped = true,TimePosition = 3.4})
	elseif gay == "ohfuck" then
		attack = true
		newmode("bye")
		hicolor = Color3.fromRGB(150,255,120)
		songid = 6156984530
		ws = 20
		attack = false
		change(bgm,{SoundId = "rbxassetid://6156984530",Pitch = 1,Looped = true,TimePosition = 0})
	elseif gay == "bye" then
		attack = true
		newmode("depressed SKID XD")
		hicolor = Color3.fromRGB(255,255,255)
		songid = 1199911787
		attack = false
		ws = 2
		change(bgm,{SoundId = "rbxassetid://1199911787",Pitch = 1,Looped = true,TimePosition = 0})
	elseif gay == "depressed SKID XD" then
		newmode("limits who")
		songid = 6928465593
		ws = 4
		change(bgm,{SoundId = "rbxassetid://6928465593",Pitch = 1,Looped = true,TimePosition = 0})

	elseif gay == "limits who" then
		attack = true
		newmode("kickisher")
		hicolor = Color3.fromRGB(200,255,220)
		songid = 6669026731
		attack = false
		ws = 1.3
		change(bgm,{SoundId = "rbxassetid://6669026731",Pitch = 1,Looped = true,TimePosition = 0})
	else
		attack = true
		newmode("hi")
		hicolor = Color3.fromRGB(51, 81, 255)
		attack = false
		songid = 5079789617
		ws = 0.5
		change(bgm,{SoundId = "rbxassetid://5079789617",Pitch = 1,Looped = true,TimePosition = 0})
	end
end
RightShoulder = t["Right Shoulder"]
LeftShoulder = t["Left Shoulder"]
RightHip = t["Right Hip"]
LeftHip = t["Left Hip"]
Neck = t["Neck"]
RootJoint = Character.HumanoidRootPart["RootJoint"]
local ROOTC0 = CFrame.new()*CFrame.Angles(math.rad(-90),0,math.rad(180))
local NECKC0 = CFrame.new(0,1,0)*CFrame.Angles(math.rad(-90),0,math.rad(180))
local RIGHTSHOULDERC0 = CFrame.new(-.5,0,0)*CFrame.Angles(0,math.rad(90),0)
local LEFTSHOULDERC0 = CFrame.new(.5,0,0)*CFrame.Angles(0,math.rad(-90),0)
local btr
debris:AddItem(bgm,0)
local cameratilt = cn()
btr = bgm.DescendantAdded:connect(function(hi)
	if hi:IsA("TremoloSoundEffect") then
		run.Heartbeat:Connect(function()
			hi.Duty = 1
		end)
	end
end)

local rc0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local nc0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local rscp = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
local lscp = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))

run.Heartbeat:Connect(function()
	sine = workspace.DistributedGameTime * 60
	r.CFrame = poscframe	
	if ypos < workspace.FallenPartsDestroyHeight then
		respawnchr()
	end
	if ypos >= 3000 then
		respawnchr()
	end
	if ypos <= -3000 then
		respawnchr()
	end
	if tick()-bgmstartime > bgmtimelength then
		bgmstartime,bgm.Name = tick(),"sdjfhsjdkhfkjsdhfsdjfyusdg"
	end
	local _tilt = cn(r.CFrame:VectorToObjectSpace(velocity))
	local tilt = {X=clamp(_tilt.X,-7,7),Y=0,Z=clamp(_tilt.Z,-7,7)}
	if not attack then
		if yvelo > 0 and not fly then
			laoffset = laoffset:Lerp(lac0*cn(-0.325000763,0.187000036,0)*euler(0,0,rad(-30)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn(0.325000763,0.187000036,0)*euler(0,0,rad(30)),animspeed)
			lloffset = lloffset:Lerp(llc0*cn(0,0.57099998,-0.45300293)*euler(rad(-7.5),0,0),animspeed)
			rloffset = rloffset:Lerp(rlc0,animspeed)
			toffset = toffset:Lerp(cn(),animspeed)
			hoffset = hoffset:Lerp(hc0,animspeed)
		elseif yvelo < 0 and not fly then
			laoffset = laoffset:Lerp(lac0*cn(-0.187999725,0.161999941,-0.46900177)*euler(rad(60),0,rad(-30)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn(0.187999725,0.161999941,-0.46900177)*euler(rad(60),0,rad(30)),animspeed)
			lloffset = lloffset:Lerp(llc0,animspeed)
			rloffset = rloffset:Lerp(rlc0*cn(0,0.57099998,-0.45300293)*euler(rad(-7.5),0,0),animspeed)
			toffset = toffset:Lerp(euler(rad(-20),0,0),animspeed)
			hoffset = hoffset:Lerp(hc0*cn(0,-0.0170001984,-0.128997803)*euler(rad(-7.5),0,0),animspeed)
		elseif moving and gay == "angry" then
			laoffset = laoffset:Lerp(lac0*cn(-0.1,0,-0.3)*euler(rad(110),0,rad(-10)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn(0.1,0,sin(sine/10)/20*tilt.Z)*euler(-rad(sin(sine/10)*3*tilt.Z),0,rad(10)),animspeed)
			lloffset = lloffset:Lerp(llc0*cn(sin(sine/10)/20*tilt.X,0,sin(sine/10)/20*tilt.Z)*euler(-rad(sin(sine/10)*3*tilt.Z),0,rad(sin(sine/10)*3*tilt.X)),animspeed)
			rloffset = rloffset:Lerp(rlc0*cn(-sin(sine/10)/20*tilt.X,0,-sin(sine/10)/20*tilt.Z)*euler(rad(sin(sine/10)*3*tilt.Z),0,-rad(sin(sine/10)*3*tilt.X)),animspeed)
			toffset = toffset:Lerp(cn(0,sin(sine/5)/10,0)*euler(rad(tilt.Z*2),0,rad(-tilt.X)),animspeed)
			hoffset = hoffset:Lerp(hc0*euler(0,-rad(tilt.X*5),0),animspeed)
			gunoffset = gunoffset:Lerp(cn(-0.125,-0.898999929-cos(sine/10)/70*tilt.Z,0.95400238)*euler(0,rad(90),rad(-172.5+cos(sine/10)*tilt.Z*1.5)),animspeed)
		elseif moving and gay == "hi" then
			laoffset = laoffset:Lerp(lac0*cn(-0.1,0,-0.3)*euler(rad(110),0,rad(-10)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn(0.1,0,sin(sine/10)/20*tilt.Z)*euler(-rad(sin(sine/10)*3*tilt.Z),0,rad(10)),animspeed)
			lloffset = lloffset:Lerp(llc0*cn(sin(sine/10)/20*tilt.X,0,sin(sine/10)/20*tilt.Z)*euler(-rad(sin(sine/10)*3*tilt.Z),0,rad(sin(sine/10)*3*tilt.X)),animspeed)
			rloffset = rloffset:Lerp(rlc0*cn(-sin(sine/10)/20*tilt.X,0,-sin(sine/10)/20*tilt.Z)*euler(rad(sin(sine/10)*3*tilt.Z),0,-rad(sin(sine/10)*3*tilt.X)),animspeed)
			toffset = toffset:Lerp(cn(0,sin(sine/5)/10,0)*euler(rad(tilt.Z*2),0,rad(-tilt.X)),animspeed)
			hoffset = hoffset:Lerp(hc0*euler(0,-rad(tilt.X*5),0),animspeed)
			gunoffset = gunoffset:Lerp(cn(-0.125,-0.898999929-cos(sine/10)/70*tilt.Z,0.95400238)*euler(0,rad(90),rad(-172.5+cos(sine/10)*tilt.Z*1.5)),animspeed)
		elseif moving and gay == "bye" then
			toffset = toffset:Lerp(CF(0, 3+.5*math.sin(sine/15), 0) * ANGLES(RAD(-50 + 3 * math.cos(sine/15)+tilt.Z*2), RAD(0), RAD(-2 * cos(sine/30)-tilt.X)), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0,-0) * ANGLES(RAD(30), RAD(0), RAD(-5*cos(sine/30))), 0.4/3)
			raoffset = raoffset:Lerp(CF(1.95, 0.3, 0.7) * ANGLES(RAD(50+-15*cos(sine/15)), RAD(-120), RAD(-30)) * ANGLES(RAD(120+4*cos(sine/30)), RAD(0), RAD(0)), 0.4/3)
			laoffset = laoffset:Lerp(CF(-1.2, -0, 0.2) * ANGLES(RAD(-0), RAD(90), RAD(-40)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.4-0.01*cos(sine/20)/7,-0.5) * ANGLES(RAD(-45+3*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(2), RAD(0), RAD(0)), 1/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.06,0.08-0.03*cos(sine/20)/7,-0.2) *ANGLES(RAD(-6+4*cos(sine/15)), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 1/2)
			gunoffset = gunoffset:Lerp(CF(-0.4,-2,0) * ANGLES(RAD(180),RAD(0),RAD(90)),0.1)
		elseif moving and gay == "ohfuck" then
			toffset = toffset:Lerp(CF(0, 3+.5*math.sin(sine/15), 0) * ANGLES(RAD(-50 + 3 * math.cos(sine/15)+tilt.Z*2), RAD(0), RAD(-2 * cos(sine/30)-tilt.X)), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0,-0) * ANGLES(RAD(30), RAD(0), RAD(-5*cos(sine/30))), 0.4/3)
			raoffset = raoffset:Lerp(CF(1.95, 0.3, 0.7) * ANGLES(RAD(50+-15*cos(sine/30)), RAD(-120), RAD(-30)) * ANGLES(RAD(120+4*cos(sine/30)), RAD(0), RAD(0)), 0.4/3)
			laoffset = laoffset:Lerp(CF(-1.2, -0, 0.2) * ANGLES(RAD(-0), RAD(90), RAD(-40)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.4-0.01*cos(sine/20)/7,-0.5) * ANGLES(RAD(-45+3*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(2), RAD(0), RAD(0)), 1/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.06,0.08-0.03*cos(sine/20)/7,-0.2) *ANGLES(RAD(-6+4*cos(sine/15)), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 1/2)
			gunoffset = gunoffset:Lerp(CF(-0.4,-2,0) * ANGLES(RAD(180),RAD(0),RAD(90)),0.1)
		elseif moving and gay == "depressed SKID XD" then
			toffset = toffset:Lerp(CF(0, 4+.5*math.sin(sine/15), 0) * ANGLES(RAD(-70+-3*math.cos(sine/17)+tilt.Z*2), RAD(0), RAD(0-tilt.X)), 0.3/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0,-0.1) * ANGLES(RAD(-30+4*cos(sine/0.000000000001)), RAD(0+4*cos(sine/0.000000000001)), RAD(-5*cos(sine/0.000000000001))), 0.3/3)
			raoffset = raoffset:Lerp(CF(1.7, 0.2+0.07*math.sin(sine/16), 0.4) * ANGLES(RAD(-20+5*cos(sine/15)), RAD(-80), RAD(40)) * ANGLES(RAD(20+4*cos(sine/17)), RAD(0), RAD(0)), 0.3/3)
			laoffset = laoffset:Lerp(CF(-0.2, 1.3+0.07*math.sin(sine/16), -0.5) * ANGLES(RAD(160+5*cos(sine/15)), RAD(90), RAD(-40)) * ANGLES(RAD(-90+4*cos(sine/18)), RAD(0), RAD(0)), 1/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.5-0.01*cos(sine/20)/7,-0.3) * ANGLES(RAD(-30+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(8), RAD(0), RAD(0)), 1/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.06,0.1-0.01*cos(sine/20)/7,-0.2) *ANGLES(RAD(20+4*cos(sine/15)), RAD(-90), RAD(10)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 1/2)
			gunoffset = gunoffset:Lerp(CF(-0.4,-0.7,0) * ANGLES(RAD(180),RAD(0),RAD(0)),0.1)
		elseif moving and gay == "kickisher" then
			toffset = toffset:Lerp(CF(0, 1.8+.2*math.sin(sine/6), 0) * ANGLES(RAD(-50), RAD(0), RAD(0)), 0.2/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0,0) * ANGLES(RAD(-30+2*cos(sine/0.000000000001)), RAD(10+2*cos(sine/0.000000000001)), RAD(-3*cos(sine/0.000000000001))), 0.4/3)
			raoffset = raoffset:Lerp(CF(1.6, -0.1+0.07*math.sin(sine/16), 0.4) * ANGLES(RAD(0+5*cos(sine/13)), RAD(-80), RAD(10)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.4/3)
			laoffset = laoffset:Lerp(CF(-0.5, 0.6, -0.5) * ANGLES(RAD(180+4*cos(sine/13)), RAD(90), RAD(-40)) * ANGLES(RAD(-30), RAD(0), RAD(0)), 1/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.02,0.3-0.2*cos(sine/20)/7,-0.5) * ANGLES(RAD(-30+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.02,0-0.2*cos(sine/18)/7,0) *ANGLES(RAD(0+4*cos(sine/15)), RAD(-90), RAD(10)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1/2)
			gunoffset = gunoffset:Lerp(CF(-0.4,-0.7,0) * ANGLES(RAD(180),RAD(0),RAD(0)),0.1)
		elseif moving and gay == "limits who" then
			toffset = toffset:Lerp(CF(0, 4+.5*math.sin(sine/15), 0) * ANGLES(RAD(-50+-5*math.cos(sine/15)), RAD(0), RAD(0)), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0,0) * ANGLES(RAD(40+4*cos(sine/15)), RAD(0), RAD(-10*cos(sine/30))), 0.7/3)
			raoffset = raoffset:Lerp(CF(1.7, -0.2+0.07*math.sin(sine/16), 0.2) * ANGLES(RAD(30+2*cos(sine/15)), RAD(-90), RAD(40)) * ANGLES(RAD(40+4*cos(sine/17)), RAD(0), RAD(0)), 0.7/3)
			laoffset = laoffset:Lerp(CF(-1.7, -0.2+0.07*math.sin(sine/16), 0.2) * ANGLES(RAD(30+2*cos(sine/15)), RAD(90), RAD(-40)) * ANGLES(RAD(40+4*cos(sine/18)), RAD(0), RAD(0)), 0.4/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.4-0.01*cos(sine/20)/7,-0.6) * ANGLES(RAD(-50+2*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(2), RAD(0), RAD(0)), 0.4/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.04,0.6-0.01*cos(sine/20)/7,0.4) *ANGLES(RAD(-40+1*cos(sine/15)), RAD(-90), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.4/2)
			gunoffset = gunoffset:Lerp(CF(0.2,0.3,0.7) * ANGLES(RAD(0),RAD(0),RAD(45)),0.1)
		elseif gay == "hi" then
			toffset = toffset:Lerp(CF(0, 0.50+.2*math.sin(sine/32), 0) * ANGLES(RAD(50), RAD(0), RAD(0)), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0.2,-0.3) * ANGLES(RAD(-40), RAD(10), RAD(0)), 0.4/3)
			raoffset = raoffset:Lerp(CF(1.5, 0.1, -0.5) * ANGLES(RAD(40), RAD(-90), RAD(10-5*math.sin(sine/24))), 0.4/3)
			laoffset = laoffset:Lerp(CF(-0.9, 0.3, -0.5) * ANGLES(RAD(-85), RAD(20), RAD(-80+5*math.sin(sine/24))), 0.4/3)
			rloffset = rloffset:Lerp(rlc0 * ANGLES(RAD(-10), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(8+2.5*math.sin(sine/32)), RAD(0)), 0.4/3)
			lloffset = lloffset:Lerp(llc0 *ANGLES(RAD(20), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(8+2.5*math.sin(sine/32)), RAD(0)), 0.4/3)
			gunoffset = gunoffset:Lerp(CF(-0.4,-1.7,0) * ANGLES(RAD(180),RAD(0),RAD(100)),0.1)
		elseif gay == "bye" then
			toffset = toffset:Lerp(CF(0, 4+.5*math.sin(sine/15), 0) * EULER(RAD(40), RAD(30), RAD(-30+5*cos(sine/30))), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0.2,-0.2) * EULER(RAD(-30), RAD(-35), RAD(-5*cos(sine/30))), 0.7/3)
			raoffset = raoffset:Lerp(CF(1.5, 0.5, -0.3) * EULER(RAD(30), RAD(-90), RAD(-30)) * EULER(RAD(10+4*cos(sine/30)), RAD(0), RAD(0)), 0.7/3)
			laoffset = laoffset:Lerp(CF(-1.5, -0, 0) * EULER(RAD(90), RAD(90), RAD(-40)) * EULER(RAD(35), RAD(0), RAD(0)), 1/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.2,0.5-0.01*cos(sine/20)/7,-0.8) * EULER(RAD(-40+3*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(22), RAD(0), RAD(0)), 1/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.04,0.08-0.01*cos(sine/20)/7,-0) *EULER(RAD(-16-2*cos(sine/15)), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 1/2)
			gunoffset = gunoffset:Lerp(CF(-0.4,-1.7,0) * EULER(RAD(180),RAD(0),RAD(100)),0.1)
		elseif gay == "depressed SKID XD" then
			toffset = toffset:Lerp(CF(0, 4+.5*math.sin(sine/15), 0) * ANGLES(RAD(20+-3*math.cos(sine/17)), RAD(20), RAD(20)), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0.2,-0.1) * ANGLES(RAD(-30+4*cos(sine/0.000000000001)), RAD(20+4*cos(sine/0.000000000001)), RAD(-5*cos(sine/0.000000000001))), 0.4/3)
			raoffset = raoffset:Lerp(CF(1.7, 0.2+0.07*math.sin(sine/16), 0.4) * ANGLES(RAD(-50+5*cos(sine/15)), RAD(-80), RAD(40)) * ANGLES(RAD(50+4*cos(sine/17)), RAD(0), RAD(0)), 0.4/3)
			laoffset = laoffset:Lerp(CF(-0.2, 1.3+0.07*math.sin(sine/16), -0.7) * ANGLES(RAD(180+5*cos(sine/15)), RAD(90), RAD(-40)) * ANGLES(RAD(-95+4*cos(sine/18)), RAD(0), RAD(0)), 1/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.5-0.01*cos(sine/20)/7,-0.5) * ANGLES(RAD(-30+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(8), RAD(0), RAD(0)), 1/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.4,0.1-0.01*cos(sine/20)/7,-0.7) *ANGLES(RAD(50+4*cos(sine/15)), RAD(-90), RAD(10)) * ANGLES(RAD(-23), RAD(0), RAD(0)), 1/2)
			gunoffset = gunoffset:Lerp(CF(-0.4,-0.7,0) * ANGLES(RAD(180),RAD(0),RAD(0)),0.1)
		elseif gay == "kickisher" then
			toffset = toffset:Lerp(CF(0, 1+.2*math.sin(sine/15), 0) * ANGLES(RAD(0), RAD(20), RAD(0)), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0,0) * ANGLES(RAD(-30+2*cos(sine/0.000000000001)), RAD(-15+2*cos(sine/0.000000000001)), RAD(-5*cos(sine/0.000000000001))), 0.4/3)
			raoffset = raoffset:Lerp(CF(1.6, -0.1+0.07*math.sin(sine/16), 0.4) * ANGLES(RAD(-20+5*cos(sine/15)), RAD(-80), RAD(10)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.4/3)
			laoffset = laoffset:Lerp(CF(-0.4, 0.6, -0.5) * ANGLES(RAD(180+3*cos(sine/15)), RAD(90), RAD(-40)) * ANGLES(RAD(-30), RAD(0), RAD(0)), 1/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.02,0.5-0.2*cos(sine/20)/7,-0.5) * ANGLES(RAD(-10+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(-0.02,0.1-0.2*cos(sine/20)/7,-0.6) *ANGLES(RAD(50+4*cos(sine/15)), RAD(-90), RAD(10)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1/2)
			gunoffset = gunoffset:Lerp(CF(-0.4,-0.7,0) * ANGLES(RAD(180),RAD(0),RAD(0)),0.1)
		elseif gay == "limits who" then
			toffset = toffset:Lerp(CF(0, 4+.5*math.sin(sine/15), 0) * ANGLES(RAD(20+-3*math.cos(sine/17)), RAD(-40), RAD(30)), 0.4/3)
			hoffset = hoffset:Lerp(hc0 * CF(0,0.2,-0.1) * ANGLES(RAD(-30+4*cos(sine/15)), RAD(35), RAD(-10*cos(sine/30))), 0.4/3)
			raoffset = raoffset:Lerp(CF(1.7, -0.2+0.07*math.sin(sine/16), 0.2) * ANGLES(RAD(10+5*cos(sine/15)), RAD(-90), RAD(40)) * ANGLES(RAD(20+4*cos(sine/17)), RAD(0), RAD(0)), 0.4/3)
			laoffset = laoffset:Lerp(CF(-1.2, 0.7+0.07*math.sin(sine/16), -0.5) * ANGLES(RAD(30+5*cos(sine/15)), RAD(90), RAD(-40)) * ANGLES(RAD(-150+4*cos(sine/18)), RAD(0), RAD(0)), 0.4/3)
			rloffset = rloffset:Lerp(rlc0 * CFrame.new(-0.06,0.5-0.01*cos(sine/20)/7,-0.5) * ANGLES(RAD(-30+5*cos(sine/15)), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 0.4/3)
			lloffset = lloffset:Lerp(llc0 * CFrame.new(0,0,0.8) *ANGLES(RAD(-40+4*cos(sine/15)), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 0.4/2)
			gunoffset = gunoffset:Lerp(CF(0.2,0.3,0.7) * ANGLES(RAD(0),RAD(0),RAD(45)),0.1)
		elseif gay == "angry" then
			toffset = toffset:Lerp(CF(0, -1+.05*math.sin(sine/32), 0) * ANGLES(RAD(-10), RAD(0), RAD(20)), 0.15 / 3.5)
			hoffset = hoffset:Lerp(hc0 * CF(0,0.2,-0.3) * ANGLES(RAD(-40), RAD(10), RAD(20)), 0.15 / 3.5)
			raoffset = raoffset:Lerp(CF(1.8, -0.1, 0.4) * ANGLES(RAD(10), RAD(-60+3*math.sin(sine/30)), RAD(100)), 0.15 / 3.5)
			laoffset = laoffset:Lerp(CF(-0.8, 0.7, -0.8) * ANGLES(RAD(140), RAD(40-3*math.sin(sine/30)), RAD(-140)), 0.15 / 3.5)
			rloffset = rloffset:Lerp(rlc0 * cn(-0.1,0.8-.05*math.sin(sine/32),-0.8) * ANGLES(RAD(15), RAD(120), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3.5)
			lloffset = lloffset:Lerp(llc0*cn(-0.2,0.4-.05*math.sin(sine/32),0.4) *ANGLES(RAD(-50), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 3.5)
			gunoffset = gunoffset:Lerp(cn(0.2,-0.7,0)*euler(0,rad(-180),rad(-180.5)),0.1)
		elseif gay == "ohfuck" then
			toffset = toffset:Lerp(CF(0, 3+.7*math.sin(sine/32), 0) * ANGLES(RAD(75 + 25 * sin(sine/26)), RAD(0), RAD(0)), 0.15 / 2)
			hoffset = hoffset:Lerp(hc0 * CF(0,0,-0.2) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.15 / 2)
			raoffset = raoffset:Lerp(CF(1.5, -0.3+0.02*sin(sine/28), 0.5) * ANGLES(RAD(-70), RAD(-90), RAD(-10-10*math.sin(sine/28))), 0.15 / 2)
			laoffset = laoffset:Lerp(CF(-0.7, 0.7, 0.3) * ANGLES(RAD(20), RAD(20), RAD(-40+5*math.sin(sine/24))), 0.15 / 1)
			rloffset = rloffset:Lerp(rlc0 * cn(0,0.7,-0.3) * ANGLES(RAD(-40 + 5 * sin(sine/21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 1)
			lloffset = lloffset:Lerp(llc0*cn(0,0.4,-0.3) *ANGLES(RAD(10 + 5 * sin(sine/23)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / 1)
			gunoffset = gunoffset:Lerp(cn(0.2,-0.5,0)*euler(0,rad(180),rad(-180.5)),0.1)
		else
			laoffset = laoffset:Lerp(lac0*cn(0.262001038-sin(sine/30)/10,-0.0739998817,-0.13999939)*euler(rad(7.44),0,rad(7.56-sin(sine/30)*7)),animspeed)
			raoffset = raoffset:Lerp(rac0*cn(-0.125,-0.125,0.217002869-sin(sine/30)/10)*euler(rad(-7.5+sin(sine/30)*7),rad(-30),0),animspeed)
			lloffset = lloffset:Lerp(llc0*euler(0,rad(15),0),animspeed)
			rloffset = rloffset:Lerp(rlc0*cn(0,0.0160000324,0.124000549)*euler(rad(-7.5),0,0),animspeed)
			toffset = toffset:Lerp(euler(rad(cos(sine/30)*2.5-2),rad(-15),0),animspeed)
			hoffset = hoffset:Lerp(cn(0,1,0)*euler(rad(cos(sine/30)*5),rad(15),rad(cos(sine/60)*10))*cn(0,0.5,0),animspeed)
			gunoffset = gunoffset:Lerp(cn(-0.6,-0.898999929+cos(sine/30)/5,0.95400238)*euler(rad(0),rad(60),rad(-182.5-cos(sine/30)*10)),animspeed)
		end
	end
	t.CFrame = r.CFrame*toffset
	h.CFrame,la.CFrame,ra.CFrame,ll.CFrame,rl.CFrame = t.CFrame*hoffset,t.CFrame*laoffset,t.CFrame*raoffset,t.CFrame*lloffset,t.CFrame*rloffset
	gun.CFrame = ra.CFrame*gunoffset
	local speen = 0
	speen = speen + 0.04
	if speen == 360 then
		speen = 0
	end
	if gay == "bye" then
		WACKYEFFECT({Time = 25,
			EffectType = "Sphere",
			Size = VT(0,0,0),
			Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25),
			Transparency = 0.3,
			Transparency2 = 1,
			CFrame = r.CFrame*CF(0,-3,0),
			MoveToPos = nil,
			RotationX = 0,
			RotationY = 0, 
			RotationZ = 0,
			Material = "Neon",
			Color = Color3.fromRGB(0+55*sick.PlaybackLoudness/100,0,0+55*sick.PlaybackLoudness/80),
			SoundID = nil,
			SoundPitch = 1,
			SoundVolume = 0})
		WACKYEFFECT({Time = 5, EffectType = "Crystal", Size = VT(0,0,0), Size2 = VT(2,2,2), Transparency = 0.1, Transparency2 = 1, CFrame = t.CFrame*laoffset*CFrame.new(0,-1.6,0)*CFrame.fromEulerAnglesXYZ(RAD(999*math.cos(sine/50)),RAD(0),RAD(999*math.cos(sine/50))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+55*sick.PlaybackLoudness/100,0,0+55*sick.PlaybackLoudness/80), SoundID = nil, SoundPitch = 1, SoundVolume = 0})		
		WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(2,2,2), Transparency = 0, Transparency2 = 1, CFrame = r.CFrame*CF(8*math.cos(sine/3),-3,8*math.sin(sine/3)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+55*sick.PlaybackLoudness/100,0,0+55*sick.PlaybackLoudness/80), SoundID = nil, SoundPitch = 1, SoundVolume = 0,oriC = CFrame.new(0,0,0),posC = CFrame.new(0,0.5,0)})		
		hicolor = Color3.fromRGB(0+135*sick.PlaybackLoudness/100,0,0+135*sick.PlaybackLoudness/80)		
	elseif gay == "depressed SKID XD" then		
		WACKYEFFECT({Time = 1, EffectType = "Block", Size = VT(7+sick.PlaybackLoudness/55,0.55,7+sick.PlaybackLoudness/55), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = r.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0+178*sick.PlaybackLoudness/100,0+178*sick.PlaybackLoudness/100), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
		WACKYEFFECT({Time = 1, EffectType = "Block", Size = VT(10+sick.PlaybackLoudness/25,0.44,10+sick.PlaybackLoudness/25), Size2 = VT(10+sick.PlaybackLoudness/55,0.44,10+sick.PlaybackLoudness/55), Transparency = 0.6, Transparency2 = 1, CFrame = r.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(0),RAD(-sick.PlaybackLoudness/2),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,0,0), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
	elseif gay == "limits who" then		
		WACKYEFFECT({Time = 47, EffectType = "Sphere", Size = VT(1.081, 0.267, 0.211), Size2 = VT(1.081, 0.267, 0.211), Transparency = 0.4, Transparency2 = 0.6, CFrame = r.CFrame*CFrame.new(10*math.sin(sine/45),math.random(-10,10),10*math.cos(sine/45))*CFrame.Angles(math.rad(speen),math.rad(180),math.rad(speen)), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "Neon", Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0+178*sick.PlaybackLoudness/100,0+178*sick.PlaybackLoudness/100), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
		WACKYEFFECT({Time = 47, EffectType = "Sphere", Size = VT(0.581, 0.067, 0.011), Size2 = VT(1.081, 0.267, 0.211), Transparency = 0.7, Transparency2 = 0.6, CFrame = r.CFrame*CFrame.new(-10*math.sin(sine/45),math.random(-10,10),-10*math.cos(sine/45))*CFrame.Angles(math.rad(speen),math.rad(180),math.rad(speen)), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "Neon", Color = Color3.fromRGB(255,0,0), SoundID = nil, SoundPitch = 0, SoundVolume = 0})
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0.581, 0.067, 0.011), Size2 = VT(1.081, 0.267, 0.211), Transparency = 0.7, Transparency2 = 0.6, CFrame = r.CFrame*CFrame.new(-5*math.sin(sine/5),math.random(-10,10),-5*math.cos(sine/5))*CFrame.Angles(math.rad(speen),math.rad(180),math.rad(speen)), MoveToPos = nil, RotationX = 1, RotationY = 1, RotationZ = 1, Material = "Neon", Color = Color3.fromRGB(0,175,255), SoundID = nil, SoundPitch = 0, SoundVolume = 0})

	end
	if gay == "limits who" then
		gun.CFrame = t.CFrame*gunoffset
		gunm.VertexColor = Vector3.new(0+bgm.PlaybackLoudness/500,0,0)
		gunlight.Color = Color3.new(0+bgm.PlaybackLoudness/500,0,0)
		cam.FieldOfView = 70 + bgm.PlaybackLoudness/55
		hicolor = Color3.new(0+bgm.PlaybackLoudness/500,0,0)
	else
		gun.CFrame = ra.CFrame*gunoffset
		gunm.VertexColor = Vector3.new(255,255,255)
		gunlight.Color = Color3.new(1,1,1)
		cam.FieldOfView = 70
	end
	c.CFrame = r.CFrame * cn(0,1.5,0)
	bgm.Volume = clamp(25/(cam.CFrame.p-r.Position).Magnitude,0,10)
end)

workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
	cam = workspace.CurrentCamera
end)
