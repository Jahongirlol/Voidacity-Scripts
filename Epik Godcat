local Player,game = owner,game
local RealPlayer = Player
local Mouse
do
	local rp = RealPlayer
	script.Parent = rp.Character
	local Event = Instance.new("RemoteEvent")
	Event.Name = "UserInput_Event"
	local function fakeEvent()
		local t = {_fakeEvent=true,Functions={},Connect=function(self,f)table.insert(self.Functions,f) end}
		t.connect = t.Connect
		return t
	end
	local m = {Target=nil,Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent()}
	local UIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent()}
	local CAS = {Actions={},BindAction=function(self,name,fun,touch,...)
		CAS.Actions[name] = fun and {Name=name,Function=fun,Keys={...}} or nil
	end}
	CAS.UnbindAction = CAS.BindAction
	local function te(self,ev,...)
		local t = m[ev]
		if t and t._fakeEvent then
			for _,f in pairs(t.Functions) do
				f(...)
			end
		end
	end
	m.TrigEvent = te
	UIS.TrigEvent = te
	Event.OnServerEvent:Connect(function(plr,io)
		if plr~=rp then return end
		m.Target = io.Target
		m.Hit = io.Hit
		if not io.isMouse then
			local b = io.UserInputState == Enum.UserInputState.Begin
			if io.UserInputType == Enum.UserInputType.MouseButton1 then
				return m:TrigEvent(b and "Button1Down" or "Button1Up")
			end
			for _,t in pairs(CAS.Actions) do
				for _,k in pairs(t.Keys) do
					if k==io.KeyCode then
						t.Function(t.Name,io.UserInputState,io)
					end
				end
			end
			m:TrigEvent(b and "KeyDown" or "KeyUp",io.KeyCode.Name:lower())
			UIS:TrigEvent(b and "InputBegan" or "InputEnded",io,false)
		end
	end)
	Event.Parent = NLS([==[
    local Player = game:GetService("Players").LocalPlayer
    local Event = script:WaitForChild("UserInput_Event")
    local Mouse = Player:GetMouse()
    local UIS = game:GetService("UserInputService")
    local input = function(io,a)
        if a then return end
        Event:FireServer({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState,Hit=Mouse.Hit,Target=Mouse.Target})
    end
    UIS.InputBegan:Connect(input)
    UIS.InputEnded:Connect(input)
    local h,t
    while wait(1/30) do
        if h~=Mouse.Hit or t~=Mouse.Target then
            h,t=Mouse.Hit,Mouse.Target
            Event:FireServer({isMouse=true,Target=t,Hit=h})
        end
    end]==],Player.Character)
	local _rg = game
	local fsmt = {
		__index = function(self,k)
			local s = rawget(self,"_RealService")
			if s then return s[k] end
		end,
		__newindex = function(self,k,v)
			local s = rawget(self,"_RealService")
			if s then s[k]=v end
		end,
		__call = function(self,...)
			local s = rawget(self,"_RealService")
			if s then return s(...) end
		end
	}
	local function FakeService(t,RealService)
		t._RealService = typeof(RealService)=="string" and _rg:GetService(RealService) or RealService
		return setmetatable(t,fsmt)
	end
	local g = {
		GetService = function(self,s)
			return self[s]
		end,
		Players = FakeService({
			LocalPlayer = FakeService({GetMouse=function(self)return m end},Player)
		},"Players"),
		UserInputService = FakeService(UIS,"UserInputService"),
		ContextActionService = FakeService(CAS,"ContextActionService"),
	}
	rawset(g.Players,"localPlayer",g.Players.LocalPlayer)
	g.service = g.GetService
	g.RunService = FakeService({
		RenderStepped = _rg:GetService("RunService").Heartbeat,
		BindToRenderStep = function(self,name,_,fun)
			self._btrs[name] = self.Heartbeat:Connect(fun)
		end,
		UnbindFromRenderStep = function(self,name)
			self._btrs[name]:Disconnect()
		end,
	},"RunService")
	setmetatable(g,{
		__index=function(self,s)
			return _rg:GetService(s) or typeof(_rg[s])=="function"
				and function(_,...)return _rg[s](_rg,...)end or _rg[s]
		end,
		__newindex = fsmt.__newindex,
		__call = fsmt.__call
	})
	game,owner,Mouse = g,g.Players.LocalPlayer,m
end

function QFCF(cf)
	local mx,my,mz,m00,m01,m02,m10,m11,m12,m20,m21,m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip,(m02 - m20) * recip,(m10 - m01) * recip,s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s,(m10 + m01) * recip,(m20 + m02) * recip,(m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip,0.5 * s,(m21 + m12) * recip,(m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip,(m12 + m21) * recip,0.5 * s,(m10 - m01) * recip
		end
	end
end

local function randomstring()
	local length = math.random(10,20)
	local array = {}
	for i = 1,length do
		array[i] = string.char(math.random(32,126))
	end
	return table.concat(array)
end
function swait(num)
	if not num or num == nil or num == 0 then
		game:GetService("RunService").Heartbeat:Wait()
	else
		for i = 1,num do
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
end
local BG = nil
local BV = nil
local Character = Player.Character
Cam = workspace.CurrentCamera
Cam.CameraSubject = Character:FindFirstChildOfClass("Humanoid")
game:GetService("RunService").RenderStepped:Connect(function()
	Player.Character = Character
	Cam.CameraSubject = Character:FindFirstChildOfClass("Humanoid")
end)
Character.PrimaryPart = Character.HumanoidRootPart
Character.Parent = workspace
local usuckmongrio = Character:Clone()
usuckmongrio.Parent = nil
Humanoid = Character.Humanoid
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local rc0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local nc0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
local rscp = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
local lscp = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))
local ROOTC0 = rc0
local NECKC0 = nc0
local RIGHTSHOULDERC0 = rscp
local LEFTSHOULDERC0 = lscp
local TIME = 0
local val = math.random(1,255)
pcall(function()
	Character.Animate:Destroy()
	Character.Humanoid.Animator:Destroy()
end)
local Gun = Instance.new("Folder",Character)
local Base,NeonParts,Joint,Hole1,Hole2 = Instance.new("Part"),Instance.new("Part"),Instance.new("Part"),Instance.new("Part"),Instance.new("Part")
Base.Size,NeonParts.Size,Joint.Size,Hole1.Size,Hole2.Size = Vector3.new(7.415, 10.11, 1.474),Vector3.new(2.049, 2.267, 9.14),Vector3.new(1, 1, 1),Vector3.new(0.1, 0.1, 0.1),Vector3.new(0.1, 0.1, 0.1)
local BaseM,NeonPartsM = Instance.new("SpecialMesh",Base),Instance.new("SpecialMesh",NeonParts)
BaseM.MeshId,NeonPartsM.MeshId = "rbxassetid://9075761456","rbxassetid://9075997501"
local BWeld,NWled,JointWeld,H1W,H2W = Instance.new("Weld",Base),Instance.new("Weld",NeonParts),Instance.new("Weld",Joint),Instance.new("Weld",Hole1),Instance.new("Weld",Hole2)
BWeld.Part0,NWled.Part0,JointWeld.Part0,H1W.Part0,H2W.Part0 = Base,NeonParts,Joint,Hole1,Hole2
BWeld.Part1,NWled.Part1,JointWeld.Part1,H1W.Part1,H2W.Part1 = Joint,Joint,RightArm,Joint,Joint
BWeld.C0,NWled.C0,JointWeld.C0,H1W.C0,H2W.C0 = CFrame.new(-2.27894592, 1.83068848, 0, -2.18556941e-08, 0.866025448, -0.49999997, 3.78551732e-08, 0.49999997, 0.866025448, 1, -1.77635684e-15, -4.37113883e-08),CFrame.new(0.00567626953, -1.34004784, -1.89547729, -1, 3.55271368e-15, 0, -1.77635684e-15, 1, 0, 0, -7.76470235e-23, -1),CFrame.new(-0.00473022461, -0.199996948, 0.503738403, 1, 4.37113883e-08, -4.37113883e-08, -4.37113883e-08, 0, -1, -4.37113883e-08, 1, 1.91068547e-15),CFrame.new(0, -1.38528061, 3.97091675, 1, -5.32907052e-15, 0, -3.55271368e-15, 1, 0, 0, 7.76470235e-23, 1),CFrame.new(0, -1.38528061, 8.6000061, 1, -5.32907052e-15, 0, -3.55271368e-15, 1, 0, 0, 7.76470235e-23, 1)
local GunJoint = JointWeld
-------------------------------------------------------------------------
local TauntRemote = {}
local ModeVal = {Value = "Corrupt"}
local stopeveryting = false
local alreadyfixing = false
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
radian = math.rad
random = math.random
Vec3 = Vector3.new
Inst = Instance.new
cFrame = CFrame.new
Euler = CFrame.fromEulerAnglesXYZ
vt = Vector3.new
bc = BrickColor.new
br = BrickColor.random
it = Instance.new
cf = CFrame.new
angles = CFrame.Angles
Cf = CFrame.new
Cos = math.cos
Sin = math.sin
Abs = math.abs
Rad = math.rad
local doe = 0
Animation_Speed = 3
local Speed = 20
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local Rooted = false
local TypeOfMode = "Godcat"
local SINE = 0
local sine = 0
local ILSine = 0
local KEYHOLD = false
local VALUE1 = false
local VALUE2 = false
local Effects = IT("Folder", Character)
Effects.Name = "Effects"
local TOBANISH = {}
local TAIL = {}
local mde = ModeVal.Value
local Hue = 0
local SIZE = 1
local ISFLYING = false

--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		game:GetService("RunService"):wait()
	else
		for i = 1, NUMBER do
			game:GetService("RunService"):wait()
		end
	end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

local function weldBetween(a, b)
	local weldd = Instance.new("ManualWeld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CFrame.new()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = a
	return weldd
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
ILThrottle = 1
function QTCF(px,py,pz,x,y,z,w)
	local xs,ys,zs = x + x,y + y,z + z
	local wx,wy,wz = w * xs,w * ys,w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px,py,pz,1 - (yy + zz),xy - wz,xz + wy,xy + wz,1 - (xx + zz),yz - wx,xz - wy,yz + wx,1 - (xx + yy))
end
function QS(a,b,t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp,finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1/math.sin(theta)
			startInterp = math.sin((1 - t) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = math.acos(-cosTheta)
			local invSinTheta = 1/math.sin(theta)
			startInterp = math.sin((t - 1) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp,a[2] * startInterp + b[2] * finishInterp,a[3] * startInterp + b[3] * finishInterp,a[4] * startInterp + b[4] * finishInterp
end
Clerp = {
	OG = function(a,b,t) 
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)} 
		local ax, ay, az = a.x, a.y, a.z 
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1-t
		return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
	end,
	IL = function(a,b,t)
		return a:Lerp(b,t < 1 and math.clamp(t*ILThrottle,0,1) or 1)
	end,
	LC = function(a,b,t)
		local qa = {QFCF(a)}
		local qb = {QFCF(b)}
		local ax,ay,az = a.x,a.y,a.z
		local bx,by,bz = b.x,b.y,b.z
		local _t = 1 - t
		return QTCF(_t * ax + t * bx,_t * ay + t * by,_t * az + t * bz,QS(qa,qb,t))
	end
}

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

function TauntRemote:FireServer(taunt,tauntid,taunttime,tauntpitch)
	ModeVal.Value = taunt
	sick.SongId = tauntid
	sick.Pitch = tauntpitch
	sick.TimePosition = taunttime
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Brick", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "meme" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "5889240287", "", SIZE, VT(0,0,0))
			local Decal = Instance.new("Decal",EFFECT)
			Decal.Texture = "rbxassetid://385855640"
		elseif TYPE == "Block2" or TYPE == "Box" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		elseif TYPE == "Hat" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "173774068", "", SIZE, VT(0,0,0))
		elseif TYPE == "Arm" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "2828256740", "", SIZE, VT(0,0,0))
		elseif TYPE == "torso" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "48112070", "", SIZE, VT(0,0,0))
		elseif TYPE == "Head" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "539723444", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block2" then
				EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block2" then
					EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function SpawnTrail(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, "Really black", "Trail", VT(0,0,0))
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(0.5,DIST,0.5)
	else
		TRAIL.Size = VT(0.25,DIST,0.25)
	end
	TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.1
		end
		TRAIL:remove()
	end))
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end
local Weapon = IT("WorldModel")
Humanoid:SetStateEnabled("Dead",false)
Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead,false)
Humanoid:SetStateEnabled("GettingUp",true)
Humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp,true)
Humanoid:SetStateEnabled("Ragdoll",false)
Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)

workspace.ChildAdded:connect(function(instance)
	for BANISH = 1, #TOBANISH do
		if TOBANISH[BANISH] ~= nil then
			if instance.Name == TOBANISH[BANISH] then
				coroutine.resume(coroutine.create(function()
					instance:ClearAllChildren()
					Debris:AddItem(instance,0.0005)
				end))
			end
		end
	end
end)

local eeeblock = Instance.new("MeshPart",game:GetService("SoundService"))
eeeblock.Name = randomstring()
eeeblock.CanCollide = false
eeeblock.Anchored = true
eeeblock.CFrame = Torso.CFrame
eeeblock.Transparency = 1
local soundfixing = false
function AutoDetect(UI)
	UI.Changed:connect(function(WC)
		if tostring(WC) == "Text" then
			if string.match(string.lower(UI.Text),"5942064279") then
				local Prefix = string.match(string.lower(UI.Text),"5942064279") or ""

				if UI:IsA("TextBox") then
					UI.Text = "Ah yes tiger ultraskidded shit, now die"
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
				if string.match(string.lower(UI.Text),"AndrSkid") then
					local Prefix = string.match(string.lower(UI.Text),"AndrSkid") or ""

					if UI:IsA("TextBox") then
						UI.Text = "No, I'm not that big😢😢😢"
						UI:ReleaseFocus(true)
					end
					if UI:IsA("TextButton") then UI:Destroy()

					end
				end
			end 
		end
	end)
end
for _,v in pairs(game:GetService("Players"):GetPlayers()) do
	coroutine.resume(coroutine.create(function()
		if v.Name ~= Player.Name then
			for _,UI in pairs(v:WaitForChild("PlayerGui"):GetDescendants()) do
				AutoDetect(UI)
			end
			v:WaitForChild("PlayerGui").DescendantAdded:connect(function(UI)
				AutoDetect(UI)
			end)
		end
	end))
end

local Killed,DeadParts = {},{}
function mainIntro()
	ATTACK = true
	for i = 0, 1, 0.1 do
		Swait()
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1,-0.15,-0.5) * ANGLES(RAD(0),RAD(90),RAD(0)) * ANGLES(RAD(-3),RAD(-15),RAD(-20)),.1)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1,-1,0) * ANGLES(RAD(0),RAD(-90),RAD(0)) * ANGLES(RAD(-3),RAD(1),RAD(20)),.1)
		RootJoint.C0 = Clerp.OG(RootJoint.C0, ROOTC0 * CF(0,0.25,-0.05) * ANGLES(RAD(-20),RAD(0),RAD(30)),.1)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * ANGLES(RAD(20),RAD(0),RAD(-30)),.1)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.45,0.8,-0.15) * ANGLES(RAD(35),RAD(-10),RAD(30)),.8)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.4,0.5,0.1) * ANGLES(RAD(-5),RAD(10),RAD(-20)),.1)
	end
	CreateSound(824687369, Torso, 10, 0.9, false)
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(150,5,150), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(160,10,160), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 1, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(170,5,170), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 2, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(180,10,180), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 3, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(190,5,190), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 4, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(200,10,200), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	CreateSound(363808674, Torso, 10, 1, false)
	for i=0, 0.5, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CFrame.new(0, 0, 0 + 0.35 * math.cos(SINE / 2)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.15 / 1)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(5), math.rad(25), math.rad(0)), 1 / 1)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CFrame.new(1.25, 0.5, -0.5) * CFrame.Angles(math.rad(100), math.rad(0), math.rad(-50)) * RIGHTSHOULDERC0, 1 / 1)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CFrame.new(-1.25, 0.35, -0.35) * CFrame.Angles(math.rad(70), math.rad(0), math.rad(60)) * LEFTSHOULDERC0, 1 / 1)
		RightHip.C0 = Clerp.OG(RightHip.C0, CFrame.new(1, -1 - 0.35 * math.cos(SINE / 2), -0.01) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.15 / 1)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CFrame.new(-1, -1 - 0.35 * math.cos(SINE / 2), -0.01) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.15 / 1)
	end
	CreateSound(363808674, Torso, 10, 1, false)
	for i=0, 0.5, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CFrame.new(0, 0, 0 + 0.35 * math.cos(SINE / 2)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.15 / 1)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CFrame.new(0, 0, 0 + ((1) - 1)) * CFrame.Angles(math.rad(5), math.rad(-25), math.rad(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CFrame.new(1.25, 0.5, -0.5) * CFrame.Angles(math.rad(100), math.rad(0), math.rad(-90)) * RIGHTSHOULDERC0, 1 / 1)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CFrame.new(-1.25, 0.35, -0.35) * CFrame.Angles(math.rad(70), math.rad(0), math.rad(90)) * LEFTSHOULDERC0, 1 / 1)
		RightHip.C0 = Clerp.OG(RightHip.C0, CFrame.new(1, -1 - 0.35 * math.cos(SINE / 2), -0.01) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.15 / 1)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CFrame.new(-1, -1 - 0.35 * math.cos(SINE / 2), -0.01) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0)) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.15 / 1)
	end
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(190,5,190), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 4, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	WACKYEFFECT({Time = 50, EffectType = "Wave", Size = Vector3.new(0,0,0), Size2 = Vector3.new(200,10,200), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(0,0,0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
	WACKYEFFECT({Time = 60, EffectType = "Sphere", Size = Vector3.new(0.5,0.55,0.5), Size2 = Vector3.new(0.5,4,0.5), Transparency = 0, Transparency2 = 1, CFrame = Head.CFrame*CFrame.new(0.4, 0.2, -0.8), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(1, 0, 0), SoundID = "rbxassetid://743521450", SoundPitch = 1.15, SoundVolume = 6})
	WACKYEFFECT({Time = 60, EffectType = "Sphere", Size = Vector3.new(0.55,0.5,0.5), Size2 = Vector3.new(4,0.5,0.5), Transparency = 0, Transparency2 = 1, CFrame = Head.CFrame*CFrame.new(0.4, 0.2, -0.8), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(1, 0, 0), SoundID = "rbxassetid://743521450", SoundPitch = 0.95, SoundVolume = 6})
	WACKYEFFECT({Time = 55, EffectType = "Skull", Size = VT(11,11,11), Size2 = VT(99,99,99), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0, 0, 0), MoveToPos = nil, RotationX = 30, RotationY = 30, RotationZ = 30, Material = "Neon", Color = Color3.new(255/255, 0/255, 0/255), SoundID = "rbxassetid://743521450", SoundPitch = 0.95, SoundVolume = 6})
	ATTACK = false	
end

function Instancee(Class,Properties)
	local Part = Instance.new(Class)
	for i,v in pairs(Properties) do
		Part[i] = v
	end
	return Part
end

function Clonee(Part,Properties)
	local ClonePart = Part:Clone()
	for i,v in pairs(Properties) do
		ClonePart[i] = v
	end
	return(ClonePart)
end

function Instanceneww(Class,Properties)
	local Part = Instance.new(Class)
	for i,v in pairs(Properties) do
		Part[i] = v
	end
	return Part
end

local Parts, PossibleParents1 = {"Part","FlagStand","MeshPart","Seat","SpawnLocation","VehicleSeat","TrussPart","WedgePart","UnionOperation","NegateOperation","CornerWedgePart"},{"SoundService","Chat","MarketplaceService","Players","StarterPlayer","LocalizationService","JointsService","FriendService","InsertService","Lighting","Teams","ReplicatedStorage","TestService","ProximityPromptService"}
Funcs = {
	characterfixer = function()
		alreadyfixing = true
		local oldpos = RootPart.CFrame
		RootJoint.C0 = Clerp.OG(RootJoint.C0,CFrame.new(0,9e9,0),1)
		Neck.C0 = Clerp.OG(Neck.C0,CFrame.new(0,9e9,0),1)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0,CFrame.new(0,9e9,0),1)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0,CFrame.new(0,9e9,0),1)
		RightHip.C0 = Clerp.OG(RightHip.C0,CFrame.new(0,9e9,0),1)
		LeftHip.C0 = Clerp.OG(LeftHip.C0,CFrame.new(0,9e9,0),1)
		local babkidainazad = Torso.Color
		local camerapos = workspace.CurrentCamera.CFrame
		pcall(function()
			Character:Remove()
		end)
		Character = usuckmongrio:Clone()
		Character.Name = randomstring()
		Character.Parent = workspace
		Humanoid = Character.Humanoid
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
		workspace.CurrentCamera.CameraSubject = Humanoid
		workspace.CurrentCamera.CameraType = "Scriptable"
		workspace.CurrentCamera.CFrame = camerapos
		coroutine.resume(coroutine.create(function()
			swait(5)
			workspace.CurrentCamera.CameraType = "Custom"
		end))
		LeftArm = Character["Left Arm"]
		RightArm = Character["Right Arm"]
		LeftLeg = Character["Left Leg"]
		RightLeg = Character["Right Leg"]
		Head = Character.Head
		Torso = Character.Torso
		Torso.Color = babkidainazad
		RootPart = Character.HumanoidRootPart
		RootPart.CFrame = oldpos
		Player.Character = Character
		RootJoint = RootPart.RootJoint
		Neck = Torso["Neck"]
		RightShoulder = Torso["Right Shoulder"]
		LeftShoulder = Torso["Left Shoulder"]
		RightHip = Torso["Right Hip"]
		LeftHip = Torso["Left Hip"]
		Effects = IT("Folder", Character)
		Effects.Name = "Effects"
		RootJoint.Part0 = RootPart
		RootJoint.Part1 = Torso
		LeftHip.Part0 = Torso
		LeftHip.Part1 = LeftLeg
		RightHip.Part0 = Torso
		RightHip.Part1 = RightLeg
		LeftShoulder.Part0 = Torso
		LeftShoulder.Part1 = LeftArm
		RightShoulder.Part0 = Torso
		RightShoulder.Part1 = RightArm
		Neck.Part0 = Torso
		Neck.Part1 = Head
		Gun = Instance.new("Folder",Character)
		local Base,NeonParts,Joint,Hole1,Hole2 = Instance.new("Part"),Instance.new("Part"),Instance.new("Part"),Instance.new("Part"),Instance.new("Part")
		Base.Size,NeonParts.Size,Joint.Size,Hole1.Size,Hole2.Size = Vector3.new(7.415, 10.11, 1.474),Vector3.new(2.049, 2.267, 9.14),Vector3.new(1, 1, 1),Vector3.new(0.1, 0.1, 0.1),Vector3.new(0.1, 0.1, 0.1)
		local BaseM,NeonPartsM = Instance.new("SpecialMesh",Base),Instance.new("SpecialMesh",NeonParts)
		BaseM.MeshId,NeonPartsM.MeshId = "rbxassetid://9075761456","rbxassetid://9075997501"
		local BWeld,NWled,JointWeld,H1W,H2W = Instance.new("Weld",Base),Instance.new("Weld",NeonParts),Instance.new("Weld",Joint),Instance.new("Weld",Hole1),Instance.new("Weld",Hole2)
		BWeld.Part0,NWled.Part0,JointWeld.Part0,H1W.Part0,H2W.Part0 = Base,NeonParts,Joint,Hole1,Hole2
		BWeld.Part1,NWled.Part1,JointWeld.Part1,H1W.Part1,H2W.Part1 = Joint,Joint,RightArm,Joint,Joint
		BWeld.C0,NWled.C0,JointWeld.C0,H1W.C0,H2W.C0 = CFrame.new(-2.27894592, 1.83068848, 0, -2.18556941e-08, 0.866025448, -0.49999997, 3.78551732e-08, 0.49999997, 0.866025448, 1, -1.77635684e-15, -4.37113883e-08),CFrame.new(0.00567626953, -1.34004784, -1.89547729, -1, 3.55271368e-15, 0, -1.77635684e-15, 1, 0, 0, -7.76470235e-23, -1),CFrame.new(-0.00473022461, -0.199996948, 0.503738403, 1, 4.37113883e-08, -4.37113883e-08, -4.37113883e-08, 0, -1, -4.37113883e-08, 1, 1.91068547e-15),CFrame.new(0, -1.38528061, 3.97091675, 1, -5.32907052e-15, 0, -3.55271368e-15, 1, 0, 0, 7.76470235e-23, 1),CFrame.new(0, -1.38528061, 8.6000061, 1, -5.32907052e-15, 0, -3.55271368e-15, 1, 0, 0, 7.76470235e-23, 1)
		local GunJoint = JointWeld
		if ISFLYING then
			BG = Instance.new('BodyGyro',RootPart)
			BV = Instance.new('BodyVelocity',RootPart)
			BG.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
			BG.P = 1e4
			BG.CFrame = RootPart.CFrame
			BV.Velocity = Vector3.new(0,0,0)
			BV.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
		end
		for i,v in pairs(Character:GetChildren()) do
			if v:IsA("BasePart") then
				local shieldpart = Instance.new("MeshPart")
				shieldpart.Name = "HumanoidRootPart"
				shieldpart.Size = v.Size + Vector3.new(.4,.4,.4)
				shieldpart.Transparency = 1
				shieldpart.Color = v.Color
				shieldpart.CanCollide = false
				shieldpart.Massless = true
				shieldpart.Parent = v
				local shieldweld = Instance.new("Weld")
				shieldweld.Name = randomstring()
				shieldweld.Part0 = v
				shieldweld.Part1 = shieldpart
				shieldweld.Parent = v
			end
		end
		alreadyfixing = false
	end,
	soundfixer = function()
		local oldpos,oldpit,oldid = sick.TimePosition,sick.Pitch,sick.SongId
		soundfixing = true
		eeeblock = Instance.new("MeshPart")
		eeeblock.Name = randomstring()
		eeeblock.CanCollide = false
		eeeblock.Anchored = true
		eeeblock.CFrame = Torso.CFrame
		eeeblock.Transparency = 1
		pcall(function()
			sick:Destroy()
		end)
		sick = Instance.new("Sound",eeeblock)
		sick.Volume = 10
		sick.EmitterSize = "inf"
		sick.Pitch = oldpit
		sick.SoundId = "rbxassetid://"..oldid
		sick.Name = randomstring()
		sick.Looped = true
		sick.TimePosition = oldpos
		sick:Play()
		soundfixing = false
	end,
	getback = function()
		for i,v in pairs(Character:GetChildren()) do
			if v:IsA("BasePart") and v.Anchored == false then
				local flot = Instance.new("BodyPosition")
				local spen = Instance.new("BodyGyro")
				local hu = math.huge
				flot.MaxForce = Vector3.new(hu,hu,hu)
				spen.MaxTorque = Vector3.new(hu,hu,hu)
				local spown = nil
				for o,b in pairs(workspace:GetDescendants()) do
					if not b:IsDescendantOf(Character) and b:IsA("SpawnLocation") then
						spown = b
					end
				end
				if spown then
					RootPart.CFrame = CFrame.new(spown.Position.X,spown.Position.Y+(spown.Size.Y/2)+6,spown.Position.Z)
				else
					local base = workspace:FindFirstChild("Base")
					if not base then
						base = workspace:FindFirstChild("Baseplate")
					end
					if base then
						RootPart.CFrame = CFrame.new(math.clamp(RootPart.Position.X,(-base.Size.X/2)+5,(base.Size.X/2)-5),base.Position.Y+(base.Size.Y/2)+6,math.clamp(RootPart.Position.Z,(-base.Size.X/2)+5,(base.Size.X/2)-5))
					else
						RootPart.CFrame = CFrame.new(math.clamp(RootPart.Position.X,-100,100),30,math.clamp(RootPart.Position.Z,-100,100))
					end
				end
				flot.Position = RootPart.Position
				flot.Parent = RootPart
				spen.CFrame = RootPart.CFrame
				spen.Parent = RootPart
				game:GetService("Debris"):AddItem(flot,1)
				game:GetService("Debris"):AddItem(spen,1)
			end
		end
	end,
	getup = function()
		RootPart.CFrame = CFrame.new(0, 200, 0)
	end,
	Aoe = function(Part)
		coroutine.resume(coroutine.create(function()
			wait(0.05)
			local remove 
			if workspace.CurrentCamera then
				if (workspace.CurrentCamera.Focus.Position - Part.Position).Magnitude <=2.5 then
					local DiedCamera = workspace.CurrentCamera
					DiedCamera.HeadScale = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368
					DiedCamera.HeadLocked = true
					local Left
					local CameraKill = DiedCamera:GetPropertyChangedSignal("HeadScale"):Connect(function()
						if DiedCamera.HeadScale ~= 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368 then
							DiedCamera.HeadScale = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368
						end
					end)
					local Remove
					local Lock = DiedCamera:GetPropertyChangedSignal("HeadLocked"):Connect(function()
						if DiedCamera.HeadLocked ~= true then
							DiedCamera.HeadLocked = true
						end
					end)
					Left = game:GetService("Players").PlayerRemoving:Connect(function(w)
						if w == game:GetService("Players").LocalPlayer then
							Left:Disconnect()
							Lock:Disconnect()
							CameraKill:Disconnect()
							Remove:Disconnect()
						end
					end)
					Remove = workspace.DescendantRemoving:Connect(function(w)
						if w == DiedCamera then
							Left:Disconnect()
							Lock:Disconnect()
							CameraKill:Disconnect()
							Remove:Disconnect()
						end
					end)
					workspace.DescendantAdded:Connect(function(w)
						if w:IsA("Camera") then
							local DiedCamera = workspace.CurrentCamera
							DiedCamera.HeadScale = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368
							DiedCamera.HeadLocked = true
							local Left
							local CameraKill = DiedCamera:GetPropertyChangedSignal("HeadScale"):Connect(function()
								if DiedCamera.HeadScale ~= 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368 then
									DiedCamera.HeadScale = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368
								end
							end)
							local Remove
							local Lock = DiedCamera:GetPropertyChangedSignal("HeadLocked"):Connect(function()
								if DiedCamera.HeadLocked ~= true then
									DiedCamera.HeadLocked = true
								end
							end)
							Left = game:GetService("Players").PlayerRemoving:Connect(function(w)
								if w == game:GetService("Players").LocalPlayer then
									Left:Disconnect()
									Lock:Disconnect()
									CameraKill:Disconnect()
									Remove:Disconnect()
								end
							end)
							Remove = workspace.DescendantRemoving:Connect(function(w)
								if w == DiedCamera then
									Left:Disconnect()
									Lock:Disconnect()
									CameraKill:Disconnect()
									Remove:Disconnect()
								end
							end)
						end
					end)
				end	
			end	
			Part.Anchored = true
			Part.CFrame = CFrame.new(0,50000,50000)
			local void = Part:GetPropertyChangedSignal("CFrame"):Connect(function()
				if Part.CFrame ~= CFrame.new(0,50000,50000) then
					Part.CFrame = CFrame.new(0,50000,50000)
				end
			end)
			local anchored = Part:GetPropertyChangedSignal("Anchored"):Connect(function()
				if Part.Anchored ~= true then
					Part.Anchored = true
				end
			end)
			remove = game.DescendantRemoving:Connect(function(p)
				if p == Part then
					remove:Disconnect()
					anchored:Disconnect()
					void:Disconnect()
				end
			end)
		end))
	end
}
sick = Instance.new("Sound",eeeblock)
sick.Volume = 10
sick.EmitterSize = "inf"
sick.SoundId = "rbxassetid://5999157245"
sick.PlaybackSpeed = 0.75
sick.Pitch = 1
sick.TimePosition = 0
sick.Name = "brecked"
sick.Looped = true
sick:Play()

workspace.DescendantRemoving:Connect(function(v)
	if stopeveryting then wait(math.huge) end
	if not alreadyfixing then
		if (v == Character or v:IsDescendantOf(Character) or Character == nil or Character.Parent == nil) then
			if Character.Parent ~= workspace or not v:IsDescendantOf(Effects) and not v:IsA("Sound") and not v:IsA("BodyMover") and not v:IsA("DataModelMesh") and not v:IsA("SoundEffect") and not v:IsA("ValueBase") and v.Parent.Name ~= "EnCorrupt" and not v:IsA("BackpackItem") and not v:IsA("GuiBase") and not v:IsA("Camera") or v.Parent == nil or v == nil then
				if v:IsA("Model") and v.Name == "EnCorrupt" and not v:FindFirstChild("DEBOUNCE BOIII") then
					pcall(function()
						Instance.new("StringValue",v).Name = "DEBOUNCE BOIII"
						v:Destroy()
					end)
					local yeaboi = v.Parent
					local shieldpart = Instance.new("MeshPart")
					shieldpart.Name = "HumanoidRootPart"
					shieldpart.Size = yeaboi.Size + Vector3.new(.4,.4,.4)
					shieldpart.Transparency = 1
					shieldpart.Color = yeaboi.Color
					shieldpart.CanCollide = false
					shieldpart.Massless = true
					shieldpart.Parent = yeaboi
					local shieldweld = Instance.new("Weld")
					shieldweld.Name = randomstring()
					shieldweld.Part0 = yeaboi
					shieldweld.Part1 = shieldpart
					shieldweld.Parent = yeaboi
				else
					Funcs.characterfixer()
				end
			end
		end
	end
end)

game:GetService("SoundService").DescendantRemoving:Connect(function(v)
	if not soundfixing then
		if v == eeeblock or v == sick then
			Funcs.soundfixer()
		end
	end
end)
--//=================================\\
--||			DAMAGING
--\\=================================//
local Size,Material,Trans,CanC,Anchored,Colora,ParentClass,ClassName = {},{},{},{},{},{},{},{}
workspace.DescendantAdded:Connect(function(Part)
	if stopeveryting then return end
	if Part:IsA("BasePart") or Part.ClassName == "FlagStand" then
		local SUSLV = 0
		for i=1,#Size do
			if Part.Size == Size[i] then
				SUSLV = SUSLV+1
			end
			if Part.Material == Material[i] then
				SUSLV = SUSLV+1
			end
			if Part.Transparency == Trans[i] then
				SUSLV = SUSLV+1
			end
			if Part.CanCollide == CanC[i] then
				SUSLV = SUSLV+1
			end
			if Part.Anchored == Anchored[i] then
				SUSLV = SUSLV+1
			end
			if Part.Color == Colora[i] then
				SUSLV = SUSLV+1
			end
			if Part.Parent.ClassName == ParentClass[i] then
				SUSLV = SUSLV+1
			end
			if Part.ClassName == ClassName[i] then
				SUSLV = SUSLV+1
			end
		end
		if SUSLV >= 7 then
			Part.CFrame = CFrame.new(-999999,1000000,99999)
			Part.Anchored = true
			Part.Changed:Connect(function()
				Part.Anchored = true
				Part.CFrame = CFrame.new(-999999,1000000,99999) 
			end)
		end
	end	
end)

function Banish(Foe)
	if Foe then
		coroutine.resume(coroutine.create(function()
			if not Foe:IsDescendantOf(Character) and Foe ~= eeeblock and Foe.Name ~= "Base" and Foe.Name ~= "Baseplate"then
				table.insert(TOBANISH,Foe.Name)
				Foe.Archivable = true
				local CLONE = Foe:Clone()
				Foe:Destroy()
				CLONE.Parent = Effects
				CLONE:BreakJoints()
				local MATERIALS = {"Glass","Neon"}
				for _, c in pairs(CLONE:GetDescendants()) do
					if  c:IsA("BasePart") or c:IsA("MeshPart") or c:IsA("FlagStand") then
						if c.Name == "Torso" or c.Name == "UpperTorso" or c == CLONE.PrimaryPart then
							CreateSound(340722848, c, 10, 1, false)
						end
						c.Anchored = true
						c.Transparency = c.Transparency + 0.2
						c.Material = MATERIALS[MRANDOM(1,2)]
						c.Color = Color3.fromRGB(val,val,val)
						if c.ClassName == "MeshPart" then
							c.TextureID = ""
						end
						if c:FindFirstChildOfClass("SpecialMesh") then
							c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
						end
						if c:FindFirstChildOfClass("Decal") then
							c:FindFirstChildOfClass("Decal"):remove()
						end
						c.Name = "Banished"
						c.CanCollide = false
					else
						c:remove()
					end
				end
				local A = false
				for i = 1, 35 do
					if A == false then
						A = true
					elseif A == true then
						A = false
					end
					for _, c in pairs(CLONE:GetDescendants()) do
						if  c:IsA("BasePart") or c:IsA("MeshPart") or c:IsA("FlagStand") then
							c.Anchored = true
							c.Material = MATERIALS[MRANDOM(1,2)]
							c.Transparency = c.Transparency + 0.8/35
							if A == false then
								c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)
							elseif A == true then
								c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)						
							end
						end
					end
					Swait()
				end
				CLONE:remove()
			end
		end))
	end
end

function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" or CHILD.ClassName == "Folder" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

local attacks = {}
function change(instance,properties)
	for i, v in next, properties do
		instance[i] = v
	end
end
function create(class,properties)
	local instance = Instance.new(class)
	instance.Name = randomstring()
	change(instance,properties)
	return instance
end
local partexclusion = {}
local debris = game:GetService("Debris")
local cn,euler,rad,random,c3,v3,clamp,sin,cos = CFrame.new,CFrame.fromEulerAnglesYXZ,math.rad,math.random,Color3.fromRGB,Vector3.new,math.clamp,math.sin,math.cos
function tween(instance,properties,duration,easingdirection,easingstyle)
	spawn(function()
		if easingstyle == nil then easingstyle = Enum.EasingStyle.Quad end
		game:GetService("TweenService"):Create(instance,TweenInfo.new(duration,easingstyle,easingdirection),properties):Play()
	end)
end
function attacks:loldiepart(p)
	if table.find(partexclusion,p) then return end
	local hum = p.Parent:FindFirstChildOfClass("Humanoid") or p.Parent.Parent:FindFirstChildOfClass("Humanoid")
	if p.Size.X > 50 or p.Size.Y > 50 or p.Size.Z > 50 and not hum then return end
	table.insert(partexclusion,p)
	p.Anchored,p.CanCollide,p.LocalTransparencyModifier,p.Transparency = true,false,1,1
	local e = create("Part",{
		Parent = workspace,
		Color = Torso.Color,
		CanCollide = false,
		CFrame = p.CFrame,
		Size = p.Size,
		Material = Enum.Material.Neon,
		Velocity = v3(random(-30,30),30,random(-30,30)),
		RotVelocity = v3(random(-15,15),random(-15,15),random(-15,15))
	})
	p.Size = v3()
	table.insert(partexclusion,e)
	local dur = random(250,400)/300
	tween(e,{Transparency=1},dur,Enum.EasingDirection.In,Enum.EasingStyle.Linear)
	debris:AddItem(e,dur)
end
function attacks:hitbox(radius,pos)
	local h = create("Part",{
		Parent = workspace,
		Color = Torso.Color,
		Anchored = true,
		CanCollide = false,
		Transparency = 1,
		Shape = Enum.PartType.Ball,
		Size = v3(radius*2,radius*2,radius*2),
		Position = pos
	})
	table.insert(partexclusion,h)
	debris:AddItem(h,0.2)
	h.Touched:Connect(function() end)
	for i, v in next, h:GetTouchingParts() do
		local hum
		pcall(function()
			hum = v.Parent:FindFirstChildOfClass("Humanoid") or v.Parent.Parent:FindFirstChildOfClass("Humanoid")
		end)
		if hum then
			for e, p in next, hum.Parent:GetDescendants() do
				if p:IsA("BasePart") and not v:IsDescendantOf(Character) and v:IsA("FlagStand") and not v:IsDescendantOf(Effects) and v ~= eeeblock then
					attacks:loldiepart(p)
				end
			end
		end
		if not v:IsDescendantOf(Character) and v:IsA("FlagStand") and not v:IsDescendantOf(Effects) and v ~= eeeblock then
			attacks:loldiepart(v)
		end
	end
end
function spawnwave(POS)
	local HITFLOOR,HITPOS = Raycast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, Character)
	local EMITPOS = HITPOS
	if HITFLOOR ~= nil then
		if HITFLOOR.Parent:FindFirstChildOfClass("Humanoid") then
			HITFLOOR,HITPOS = Raycast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, HITFLOOR.Parent)
			EMITPOS = HITPOS
		elseif HITFLOOR.Parent.Parent:FindFirstChildOfClass("Humanoid") then
			HITFLOOR,HITPOS = Raycast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, HITFLOOR.Parent.Parent)
			EMITPOS = HITPOS
		end
	end
	if HITFLOOR ~= nil then
		mdmg(EMITPOS,55)
		attacks:hitbox(55,EMITPOS)
		WACKYEFFECT({EffectType = "Sphere", Size = VT(55,100000,55), Size2 = VT(0,100000,0), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val,val,val), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
		WACKYEFFECT({TIME = MRANDOM(0,44), EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(77 + 7 * COS(SINE/4),2 + 6 * COS(SINE/4),77 + 4 * COS(SINE/4)), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-22,22), RotationZ = 0, Material = "ForceField", Color = Color3.fromRGB(val,val,val), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		for i = 1, 5 do
			local TOPOS = CF(EMITPOS)*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))*CF(0,0,12)
			WACKYEFFECT({TIME = MRANDOM(0,44), EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(77 + 7 * COS(SINE/4),2 + 6 * COS(SINE/4),77 + 4 * COS(SINE/4)), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS,TOPOS.p), MoveToPos = TOPOS.p, RotationX = 0, RotationY = MRANDOM(-22,22), RotationZ = 0, Material = "ForceField", Color = Color3.fromRGB(val,val,val), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		end
	end
end

function Kill(Char)
	local NewCharacter = IT("Model",Effects)
	NewCharacter.Name = "Ow im ded ;-;"
	for _, c in pairs(Char:GetDescendants()) do
		if  c:IsA("BasePart") or c:IsA("MeshPart") or c:IsA("FlagStand") and c.Transparency == 0 then
			c:BreakJoints()
			c.Material = "Glass"
			c.Color = C3(0.5,0,0)
			c.CanCollide = true
			c.Transparency = 0.3
			if c:FindFirstChildOfClass("SpecialMesh") then
				c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
			end
			if c.Name == "Head" then
				c:ClearAllChildren()
				c.Size = VT(c.Size.Y,c.Size.Y,c.Size.Y)
			end
			if c.ClassName == "MeshPart" then
				c.TextureID = ""
			end
			if c:FindFirstChildOfClass("BodyPosition") then
				c:FindFirstChildOfClass("BodyPosition"):remove()
			end
			if c:FindFirstChildOfClass("ParticleEmitter") then
				c:FindFirstChildOfClass("ParticleEmitter"):remove()
			end
			c.Parent = NewCharacter
			c.Name = "DeadPart"
			c.Velocity = VT(MRANDOM(-45,45),MRANDOM(-45,45),MRANDOM(-45,45))/15
			c.RotVelocity = VT(MRANDOM(-45,45),MRANDOM(-15,85),MRANDOM(-45,45))
		end
	end
	Char:remove()
	Debris:AddItem(NewCharacter,5)
end

function AttackGyro()
	local GYRO = Instance.new("BodyGyro",RootPart)
	GYRO.D = 25
	GYRO.P = 20000
	GYRO.MaxTorque = Vector3.new(0,4000000,0)
	GYRO.CFrame = CFrame.new(RootPart.Position,Mouse.Hit.p)
	coroutine.resume(coroutine.create(function()
		repeat if stopeveryting then wait(math.huge) end
			swait()
			GYRO.CFrame = CFrame.new(RootPart.Position,Mouse.Hit.p)
		until not ATTACK
		GYRO:Destroy()
	end))
end

local shade = Color3.fromRGB(128,128,128)
function Effect(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or Vector3.new(1,1,1))
	local ENDSIZE = (Table.Size2 or Vector3.new())
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or shade)
	local hOK,sOK,vOK = Color3.toHSV(COLOR)
	local RAINBOWPART = false
	if sOK > .1 then
		RAINBOWPART = true
	end
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3,Effects,MATERIAL,0,TRANSPARENCY,shade,"Effect",Vector3.new(1,1,1),true)
		if RAINBOWPART then
			coroutine.resume(coroutine.create(function()
				while not stopeveryting and EFFECT:IsDescendantOf(game) do
					EFFECT.Color = Torso.Color
					swait()
				end
			end))
		end
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = Instance.new("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,0.1),Vector3.new())
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","168892432","",SIZE,Vector3.new())
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1,TIME+1 do
					swait()
					MSH.Scale = MSH.Scale - (Vector3.new((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1,TIME+1 do
					swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat if stopeveryting then wait(math.huge) end swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:Destroy()
			else
				repeat if stopeveryting then wait(math.huge) end swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:Destroy()
			end
		end
	end))
end

function Lightning(Part0,Part1,Timess,Offset,Color,Timer,sSize,eSize,Trans,Boomer,sBoomer,Trans2)
	local magz = (Part0 - Part1).Magnitude
	local Times = math.floor(math.clamp(magz/10,1,20))
	local curpos = Part0
	local trz = {
		-Offset,
		Offset
	}
	for i = 1,Times do
		local li = Instance.new("Part",Effects)
		li.Name = randomstring()
		li.TopSurface = 0
		li.Material = "Neon"
		li.BottomSurface = 0
		li.Anchored = true
		li.Locked = true
		li.Transparency = 0
		li.Color = Color
		li.formFactor = "Custom"
		li.CanCollide = false
		li.Size = Vector3.new(0.1,0.1,magz/Times)
		local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])
		local trolpos = CFrame.new(curpos,Part1) * CFrame.new(0,0,magz/Times).Position + Offzet
		if Times == i then
			local magz2 = (curpos - Part1).Magnitude
			li.Size = Vector3.new(0.1,0.1,magz2)
			li.CFrame = CFrame.new(curpos,Part1) * CFrame.new(0,0,-magz2/2)
		else
			li.CFrame = CFrame.new(curpos,trolpos) * CFrame.new(0,0,magz/Times/2)
		end
		curpos = li.CFrame * CFrame.new(0,0,magz/Times/2).Position
		li:Destroy()
		Effect({Time = Timer,EffectType = "Box",Size = Vector3.new(sSize,sSize,li.Size.Z),Size2 = Vector3.new(eSize,eSize,li.Size.Z),Transparency = Trans,Transparency2 = Trans2 or 1,CFrame = li.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = li.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = Boomer,Boomerang = 0,SizeBoomerang = sBoomer})
	end
end

local Mater,Size,Tran,Anc,CanC,Class = {},{},{},{},{},{}
local Parents = {"Workspace","SoundService","Chat","MarketplaceService","Players","StarterPlayer","LocalizationService","JointsService","FriendService","InsertService","Lighting","Teams","ReplicatedStorage","TestService","ProximityPromptService"}
function mdmg(centerofeffect,range)
	pcall(function()
		for i=1,#Parents do
			for i,v in pairs(game:GetService(Parents[i]):GetDescendants()) do
				if not v:IsDescendantOf(Character) and v:IsA("BasePart") and v ~= eeeblock and v.Name ~= "Base" and v.Name ~= "Baseplate" and (v.Position - centerofeffect).Magnitude <= range + v.Size.Magnitude then
					for g,h in pairs(v:GetDescendants()) do
						if h:IsA("Trail") then
							h.Attachment0 = nil
							h.Attachment1 = nil
						end 
					end
					table.insert(Material,v.Material)
					table.insert(Size,v.Size)
					table.insert(Trans,v.Transparency)
					table.insert(Anchored,v.Anchored)
					table.insert(CanC,v.CanCollide)
					table.insert(Colora,v.Color)
					table.insert(ParentClass,v.Parent.ClassName)
					table.insert(ClassName,v.ClassName)
					v.CFrame = CFrame.new(-100000,10,0)
					v.Changed:Connect(function()
						v.CFrame = CFrame.new(-100000,10,0) 
					end)
				end 
				if not v:IsDescendantOf(Character) and v:IsA("FlagStand") and v ~= eeeblock and v.Name ~= "Base" and v.Name ~= "Baseplate" and (v.Position - centerofeffect).Magnitude <= range + v.Size.Magnitude then
					local w = v.CFrame
					for g,h in pairs(v:GetDescendants()) do
						if h:IsA("Trail") then
							h.Attachment0 = nil
							h.Attachment1 = nil
						end 
					end
					v.CFrame = CFrame.new(-100000,10,0)
					v.Changed:Connect(function()
						v.CFrame = CFrame.new(-100000,10,0) 
					end)	
				end 
			end
		end
	end)
end

local FLYING = false
iyflyspeed = 3
function sFLY()
	if not ISFLYING then
		FLYING = false
	else
		local CONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
		local lCONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
		local SPEED = 0			
		local function FLY()
			FLYING = true
			BG = Instance.new('BodyGyro',RootPart)
			BV = Instance.new('BodyVelocity',RootPart)
			BG.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
			BG.P = 1e4
			BG.CFrame = RootPart.CFrame
			BV.Velocity = Vector3.new(0,0,0)
			BV.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
			coroutine.resume(coroutine.create(function()
				repeat if stopeveryting then wait(math.huge) end
					game:GetService("RunService").RenderStepped:Wait()
					if not alreadyfixing then
						if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
							SPEED = 50
						elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
							SPEED = 0
						end
						if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
							BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R,(CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2,0).Position) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
							lCONTROL = {F = CONTROL.F,B = CONTROL.B,L = CONTROL.L,R = CONTROL.R}
						elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
							BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R,(lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2,0).Position) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
						else
							BV.Velocity = Vector3.new(0,0,0)
						end
						BG.CFrame = workspace.CurrentCamera.CoordinateFrame
					end
				until not FLYING
				CONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
				lCONTROL = {F = 0,B = 0,L = 0,R = 0,Q = 0,E = 0}
				SPEED = 0
				if not alreadyfixing then
					for i,v in pairs(RootPart:GetChildren()) do
						if v:IsA("BodyMover") then
							v:Destroy()
						end
					end
					RootPart.CFrame = CFrame.new(RootPart.Position)
				end
			end))
		end
		local IYMouse = Player:GetMouse()
		IYMouse.KeyDown:connect(function(KEY)
			if stopeveryting then wait(math.huge) end
			if KEY:lower() == 'w' then
				CONTROL.F = iyflyspeed
			elseif KEY:lower() == 's' then
				CONTROL.B = - iyflyspeed
			elseif KEY:lower() == 'a' then
				CONTROL.L = - iyflyspeed
			elseif KEY:lower() == 'd' then 
				CONTROL.R = iyflyspeed
			elseif KEY:lower() == 'e' then
				CONTROL.Q = iyflyspeed*2
			elseif KEY:lower() == 'q' then
				CONTROL.E = -iyflyspeed*2
			end
		end)
		IYMouse.KeyUp:connect(function(KEY)
			if stopeveryting then wait(math.huge) end
			if KEY:lower() == 'w' then
				CONTROL.F = 0
			elseif KEY:lower() == 's' then
				CONTROL.B = 0
			elseif KEY:lower() == 'a' then
				CONTROL.L = 0
			elseif KEY:lower() == 'd' then
				CONTROL.R = 0
			elseif KEY:lower() == 'e' then
				CONTROL.Q = 0
			elseif KEY:lower() == 'q' then
				CONTROL.E = 0
			end
		end)
		FLY()
	end
end

--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//

function Taunt()
	ATTACK = true
	Rooted = true
	CreateSound(1076231331,Head,80,1,false)
	for i = 1, 21 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0.1, -0.1 + 0.05 * SIN(SINE / 12)) * ANGLES(RAD(1), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 2.5 * SIN(SINE / 12)), RAD(1 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(130), RAD(0), RAD(15)) * ANGLES(RAD(20), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.3 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(130), RAD(0), RAD(-15)) * ANGLES(RAD(20), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(1), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(1), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i = 1, 21 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0.1, -0.1 + 0.05 * SIN(SINE / 12)) * ANGLES(RAD(1), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 2.5 * SIN(SINE / 12)), RAD(7 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(100), RAD(0), RAD(15)) * ANGLES(RAD(20), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.3 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(100), RAD(0), RAD(-15)) * ANGLES(RAD(20), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(1), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(1), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i = 0.8, 18 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0.1, -0.1 + 0.05 * SIN(SINE / 12)) * ANGLES(RAD(1), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 2.5 * SIN(SINE / 12)), RAD(1 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(130), RAD(0), RAD(15)) * ANGLES(RAD(20), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.3 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(130), RAD(0), RAD(-15)) * ANGLES(RAD(20), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(1), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(1), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i = 0.7, 16 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0.1, -0.1 + 0.05 * SIN(SINE / 12)) * ANGLES(RAD(1), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 2.5 * SIN(SINE / 12)), RAD(7 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(80), RAD(0), RAD(15)) * ANGLES(RAD(20), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.3 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(80), RAD(0), RAD(-15)) * ANGLES(RAD(20), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(1), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(1), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i = 0.1, 4 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end
	for i = 0.1, 4 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end
	for i = 0.1, 4 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end
	for i = 0.1, 4 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end
	for i = 0.1, 4 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end
	for i = 0.1, 4 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end
	for i = 0.1, 4 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end
	for i = 0.1, 4 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end
	for i = 0.1, 4 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end
	for i = 0.1, 4 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end
	for i = 0.1, 4 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))), 0.35 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000)), RAD(MRANDOM(-9000,9000))) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end


function shot_lol_die_minecrft_csdfbgvsdfbngjdsgvvsdfgvdfgvgfsddhijsukzc()
	ATTACK = true
	Rooted = false
	for i=0, 0.005, 0.05 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 2+1*COS(SINE/18)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
	end
	repeat
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 2+1*COS(SINE/18)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(RightArm.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(RightArm.Position,POS)
		attacks:hitbox(2,Mouse.Hit.p)
		if HIT ~= nil then
			if HIT.Parent ~= workspace then
				Banish(HIT.Parent)
			end
		end
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = RightArm.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val,val,val), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val,val,val), SoundID = "rbxassetid://136523485", SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val,val,val), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val,val,val), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		Humanoid.CameraOffset = VT(MRANDOM(-5,5)/2.5,MRANDOM(-5,5)/2.5,MRANDOM(-5,5)/2.5)/30
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 2+1*COS(SINE/18)) * ANGLES(RAD(-5), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(130), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function Karma_Beam()
	ATTACK = true
	Rooted = false
	for i=0, 0.005, 0.05 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90+MRANDOM(-90,90)), RAD(0), RAD(60+MRANDOM(-90,90))) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
	end
	repeat
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90+MRANDOM(-90,90)), RAD(0), RAD(60+MRANDOM(-90,90))) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		end

		local HIT2,POS2 = CastProperRay(RightArm.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(RightArm.Position,POS2,false)
		if HIT2 ~= nil then
			if HIT2.Parent ~= workspace and HIT2.Parent.ClassName ~= "Folder" then
				Banish(HIT2.Parent)
			end
		end
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(5,0,5), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = RightArm.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(5,0,5), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = "rbxassetid://340722848", SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(5,0,5), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS2,RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(5,0,5), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS2,RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		Humanoid.CameraOffset = VT(MRANDOM(-5,5)/2.5,MRANDOM(-5,5)/2.5,MRANDOM(-5,5)/2.5)/30
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(130), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function shot()
	ATTACK = true
	Rooted = false
	for i=0, 0.005, 0.05 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 2+1*COS(SINE/26)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
	end
	repeat
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 2+1*COS(SINE/26)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(RightArm.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(RightArm.Position,POS)
		if HIT ~= nil then
			if HIT.Parent ~= workspace then
				Banish(HIT.Parent)
			end
		end
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = RightArm.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000), SoundID = "rbxassetid://136523485", SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		Humanoid.CameraOffset = VT(MRANDOM(-5,5)/2.5,MRANDOM(-5,5)/2.5,MRANDOM(-5,5)/2.5)/30
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 2+1*COS(SINE/26)) * ANGLES(RAD(-5), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(130), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function shot2()
	ATTACK = true
	Rooted = false
	for i=0, 0.005, 0.05 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 2+1*COS(SINE/26)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	repeat
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 2+1*COS(SINE/26)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(RightArm.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(RightArm.Position,POS)
		if HIT ~= nil then
			if HIT.Parent ~= workspace then
				Banish(HIT.Parent)
			end
		end
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = RightArm.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000), SoundID = 136523485, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		Humanoid.CameraOffset = VT(MRANDOM(-5,5)/2.5,MRANDOM(-5,5)/2.5,MRANDOM(-5,5)/2.5)/30
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 2+1*COS(SINE/26)) * ANGLES(RAD(-5), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(130), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function AttackTemplate()
	ATTACK = true
	Rooted = false
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function WarpMeteor()
	local DIST = (RootPart.Position - Mouse.Hit.p).Magnitude
	if DIST > 9999 then
		DIST = 9999
	end
	local RAY,RAYPOS = Raycast(RootPart.Position, (CF(RootPart.Position, Mouse.Hit.p)).lookVector, DIST, workspace)	
	local HITFLOOR,HITPOS,Dex = Raycast(RAYPOS+VT(0,45,0), (CF(RAYPOS, RAYPOS + VT(0, -1, 0))).lookVector, 75*SIZE, Character)
	if HITFLOOR then
		local POS = HITPOS	
		ATTACK = true
		Rooted = false
		local WARPED = false
		local SMASHED = false
		local HITFLOOR,HITPOS,Dex = Raycast(RootPart.Position+VT(0,1,0), (CF(RAYPOS, RAYPOS + VT(0, -1, 0))).lookVector, 25*SIZE, Character)
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(25 - 4 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / 12)), RAD(-55 + 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp.OG(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			until WARPED == true
			repeat
				Swait()
				RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(25 - 4 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / 12)), RAD(-55 + 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp.OG(RightHip.C0, CF(1*SIZE, -0.5*SIZE + 0.06 * SIN(SINE / 24) - 0.1*SIZE * COS(SINE / 12), -0.5*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.1*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			until SMASHED == true
			repeat
				Swait()
				RootJoint.C0 = Clerp.OG(RootJoint.C0, ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(90), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(-40), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(170), RAD(-15), RAD(20)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(170), RAD(15), RAD(-20)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp.OG(RightHip.C0, CF(1*SIZE, -1*SIZE, -0.3*SIZE) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.3*SIZE) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			until ATTACK == false
		end))
		VALUE1 = true
		CreateSound(233856115, Torso, 5, 1.6, false)
		for i = 1, 25 do
			Swait()
			for _, c in pairs(Character:GetChildren()) do
				if c.ClassName == "Part" then
					c.Transparency = c.Transparency + 1/25
				end
			end
		end
		UNANCHOR = false
		RootPart.Anchored = true
		RootPart.Velocity = VT(0,0,0)
		local ROOTPOS = RootPart.Position
		RootPart.CFrame = CF(POS+VT(0,300,0),VT(ROOTPOS.X,POS.Y+300,ROOTPOS.Z))
		WARPED = true
		for i = 1, 25 do
			Swait()
			for _, c in pairs(Character:GetChildren()) do
				if c.ClassName == "Part" then
					c.Transparency = c.Transparency - 1/25
				end
			end
		end
		local SHELL = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Part", VT(0,0,0))
		SHELL.CFrame = RootPart.CFrame
		MakeForm(SHELL,"Ball")
		CreateSound(2648563122, SHELL, 5, 1.6, false)
		for i = 1, 10 do
			Swait()
			SHELL.Transparency = SHELL.Transparency - 1/10
			SHELL.Size = SHELL.Size + VT(0.6,0.6,0.6)*1.8
		end
		for i = 1, math.ceil(75/2) do
			Swait()
			RootPart.CFrame = RootPart.CFrame*CF(0,-3.5*2,0)
			SHELL.CFrame = CF(RootPart.Position)
			WACKYEFFECT({Time = 5, EffectType = "Sphere", Size = SHELL.Size, Size2 = VT(50,3,50), Transparency = 0.5, Transparency2 = 1, CFrame = SHELL.CFrame, MoveToPos = SHELL.Position+VT(0,15,0), RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = SHELL.Color, SoundID = nil, SoundPitch = 0.75, SoundVolume = 6})
			WACKYEFFECT({Time = 15, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = LeftArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 15, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = RightArm.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 15, EffectType = "Arm", Size = VT(2.05,1.05,1.05), Size2 = VT(2.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = Torso.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 15, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = LeftLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 15, EffectType = "Arm", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = RightLeg.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 15, EffectType = "Head", Size = VT(1.05,1.05,1.05), Size2 = VT(1.05,1.05,1.05), Transparency = 0.5, Transparency2 = 0.5, CFrame = Head.CFrame*CF(0,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Plastic", 	Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		end
		RootPart.CFrame = CF(POS+VT(0,1,0),VT(ROOTPOS.X,HITPOS.Y+1,ROOTPOS.Z))
		SHELL.CFrame = CF(RootPart.Position)
		WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = SHELL.Size, Size2 = VT(350,350,350)*4, Transparency = 0, Transparency2 = 1, CFrame = SHELL.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = SHELL.Color, SoundID = "rbxassetid://157878578", SoundPitch = 0.75, SoundVolume = 10})
		WACKYEFFECT({Time = 55, EffectType = "Wave", Size = VT(SHELL.Size.X,5,SHELL.Size.Z), Size2 = VT(450,3,450)*3.8, Transparency = 0, Transparency2 = 1, CFrame = SHELL.CFrame, MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = SHELL.Color, SoundID = nil, SoundPitch = 0.75, SoundVolume = 6})
		WACKYEFFECT({Time = 55, EffectType = "Wave", Size = VT(SHELL.Size.X,5,SHELL.Size.Z), Size2 = VT(450,3,450)*4, Transparency = 0, Transparency2 = 1, CFrame = SHELL.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = SHELL.Color, SoundID = nil, SoundPitch = 0.75, SoundVolume = 6})
		for i = 1, 5 do
			WACKYEFFECT({Time = 35, EffectType = "Wave", Size = VT(50,0,50)*SIZE, Size2 = VT(350,3,350)*4, Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(225/255, 225/255, 0/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		end
		SHELL:remove()
		attacks:hitbox(750,RootPart.Position)
		mdmg(RootPart.Position,750)
		SMASHED = true
		wait(1)
		VALUE1 = false
		UNANCHOR = true
		ATTACK = false
		Rooted = false
	end
end

function Snap()
	ATTACK = true
	Rooted = false
	for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 , 0+ 0.05 * COS(SINE / 28) , 0+ 0.1 * COS(SINE / 28)) * ANGLES(RAD(0+ 4 * COS(SINE / 28)), RAD(0), RAD(0)), 0.35 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0+MRANDOM(-5,5)), RAD(0+MRANDOM(-5,5)), RAD(0+MRANDOM(-5,5))), 0.35 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0+ 5 * COS(SINE / 28)), RAD(0), RAD(5+ 5 * COS(SINE / 28)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0+ 5 * COS(SINE / 28)), RAD(0), RAD(-5- 5 * COS(SINE / 28))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1- 0.1 * COS(SINE / 28), 0- 0.05 * COS(SINE / 28)) * ANGLES(RAD(0+ 4 * COS(SINE / 28)), RAD(-5), RAD(3)) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1- 0.1 * COS(SINE / 28) , 0- 0.05 * COS(SINE / 28)) * ANGLES(RAD(0+ 4 * COS(SINE / 28)), RAD(5), RAD(-3)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
	end
	repeat
		for i=0, 0.1, 0.005 / Animation_Speed do
			Swait()
			WACKYEFFECT({Time = MRANDOM(5,35), EffectType = "Block2", Size = VT(0.3,0.3,0.3), Size2 = VT(0.1,0.1,0.1), Transparency = 0, Transparency2 = 0, CFrame = RightArm.CFrame*CF(0+MRANDOM(-2,2),-1+MRANDOM(-2,2),0+MRANDOM(-1,1))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))), MoveToPos = RightArm.CFrame*CF(0,-1,0).p, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(math.random(0,255),255,255), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 , 0+ 0.05 * COS(SINE / 28) , 0+ 0.1 * COS(SINE / 28)) * ANGLES(RAD(0+ 4 * COS(SINE / 28)), RAD(0), RAD(0)), 0.35 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-20+MRANDOM(-25,25)), RAD(0+MRANDOM(-25,25)), RAD(-20+MRANDOM(-25,25))), 0.35 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(140+MRANDOM(-25,25)), RAD(0+MRANDOM(-25,25)), RAD(0+MRANDOM(-25,25)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0+ 5 * COS(SINE / 28)), RAD(0), RAD(-5- 5 * COS(SINE / 28))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1- 0.1 * COS(SINE / 28), 0- 0.05 * COS(SINE / 28)) * ANGLES(RAD(0+ 4 * COS(SINE / 28)), RAD(-5), RAD(3)) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1- 0.1 * COS(SINE / 28) , 0- 0.05 * COS(SINE / 28)) * ANGLES(RAD(0+ 4 * COS(SINE / 28)), RAD(5), RAD(-3)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(RightArm.Position, Mouse.Hit.p, 1000, Character)
		ApplyAoE(POS,3,true)
		CreateSound(2930668938, Torso, 5, 1, false)
		for i=0, 0.1, 0.008 / Animation_Speed do
			Swait()
			WACKYEFFECT({Time = 10, EffectType = "Block2", Size = VT(0.3,0.3,0.3), Size2 = VT(0.1,0.1,0.1), Transparency = 0, Transparency2 = 0, CFrame = CF(POS,RightArm.Position)*CF(0,0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))), MoveToPos = CF(POS,RightArm.Position)*CF(0+MRANDOM(-2,2),0+MRANDOM(-2,2),0+MRANDOM(-1,1)).p, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(math.random(0,255),255,255), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 10, EffectType = "Block2", Size = VT(0.3,0.3,0.3), Size2 = VT(0.1,0.1,0.1), Transparency = 0, Transparency2 = 0, CFrame = CF(POS,RightArm.Position)*CF(0,0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))), MoveToPos = CF(POS,RightArm.Position)*CF(0+MRANDOM(-2,2),0+MRANDOM(-2,2),0+MRANDOM(-1,1)).p, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(math.random(0,255),255,255), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 , 0+ 0.05 * COS(SINE / 28) , 0+ 0.1 * COS(SINE / 28)) * ANGLES(RAD(0+ 4 * COS(SINE / 28)), RAD(0), RAD(0)), 0.35 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(10+MRANDOM(-25,25)), RAD(0+MRANDOM(-25,25)), RAD(-20+MRANDOM(-25,25))), 0.35 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90+MRANDOM(-25,25)), RAD(20+MRANDOM(-25,25)), RAD(0+MRANDOM(-25,25)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0+ 5 * COS(SINE / 28)), RAD(0), RAD(-5- 5 * COS(SINE / 28))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1- 0.1 * COS(SINE / 28), 0- 0.05 * COS(SINE / 28)) * ANGLES(RAD(0+ 4 * COS(SINE / 28)), RAD(-5), RAD(3)) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1- 0.1 * COS(SINE / 28) , 0- 0.05 * COS(SINE / 28)) * ANGLES(RAD(0+ 4 * COS(SINE / 28)), RAD(5), RAD(-3)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function Banisher_Bullet()
	ATTACK = true
	Rooted = false
	for i=0, 0, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(SINE / 12)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.6 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(35)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(-25)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	repeat
		for i=0, 0, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(SINE / 12)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.6 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(20), RAD(-20), RAD(0)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1, 0.5, -0.3) * ANGLES(RAD(70), RAD(20), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.3, 0.2) * ANGLES(RAD(-15), RAD(10), RAD(-10)) * LEFTSHOULDERC0, 2 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(35)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(-25)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(RightArm.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(RightArm.Position,POS)
		if HIT ~= nil then
			if HIT.Parent ~= workspace then
				Banish(HIT.Parent)
			end
		end
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = RightArm.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(), SoundID = "rbxassetid://904440937", SoundPitch = MRANDOM(8,11)/10, SoundVolume = 0.3})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 0.3})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 0.3})
		for i=0, 0, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 0.6 * COS(SINE / 12)) * ANGLES(RAD(-10), RAD(5), RAD(0)), 0.6 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(20), RAD(-20), RAD(0)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1, 0.5, -0.3) * ANGLES(RAD(70), RAD(20), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.3, 0.2) * ANGLES(RAD(-10), RAD(10), RAD(-10)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(35)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(-25)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function mUrDeR()
	ATTACK = true
	Rooted = false
	repeat
		for i=0, 2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 3 + 1 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-10), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-10), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			spawnwave(Mouse.Hit.p)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function beam()
	ATTACK = true
	Rooted = false
	for i=0,2,.5 / Animation_Speed do
		Swait()
		spawnwave(Mouse.Hit.p)
	end
	ATTACK = false
	Rooted = false
end

function CreateRing(SIZE,DOESROT,ROT,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0,0,0))
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "FileMesh"
	mesh.MeshId = "http://www.roblox.com/asset/?id=3270017"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	wave.Color = C3(1,0,0)
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			local val = MRANDOM(1,255)
			wave.Color = Color3.fromRGB(val,val,val)
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
			end
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end
function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			wave.Color = C3(0,0,0)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function GetRoot(MODEL, ROOT)
	if ROOT == true then
		return MODEL:FindFirstChild("HumanoidRootPart") or MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
	else
		return MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
	end
end

function SpecialSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Eye", VT(1,1,1), true)
	wave.Color = COLOR
	local mesh = CreateMesh("SpecialMesh", wave, "Sphere", "", "", SIZE, VT(0,0,0))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function Slice(KIND,SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC("Really red"), "Effect", VT(1,1,1), true)
	local mesh = nil
	if KIND == "Base" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "448386996", "", VT(0,SIZE/10,SIZE/10), VT(0,0,0))
	elseif KIND == "Thin" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662586858", "", VT(SIZE/10,0,SIZE/10), VT(0,0,0))
	elseif KIND == "Round" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662585058", "", VT(SIZE/10,0,SIZE/10), VT(0,0,0))
	end
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW/10
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function Warp()
	local POS = Mouse.Hit.p+VT(0,4,0)
	local ORI = RootPart.Orientation
	RootPart.CFrame = CF(POS)
	RootPart.Orientation = ORI
	RootJoint.Parent = RootPart    
	CreateSound("424195979",RootPart,7,2,false)
	for i = 1,4.5,.15 do 
		SpecialSphere(VT(2,10,2)/6,35,CF(POS,RootPart.Position)*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))*CF(0,MRANDOM(4,8),0),Color3.new(0,0,0),VT(0,0,0))	
		SpecialSphere(VT(2,10,2)/6,35,CF(POS,RootPart.Position)*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))*CF(0,MRANDOM(4,8),0),Color3.new(0,0,0),VT(0,0,0))	
		WACKYEFFECT({Time=20,EffectType = "Sphere", Size = VT(4*i,65*(1-i/4.5),4*i), Size2 = VT(5*i,0,5*i), Transparency = 0, Transparency2 = 1, CFrame = CF(POS)*ANGLES(0,360*math.rad(i),0), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time=20,EffectType = "Sphere", Size = VT(4*i,65*(1-i/4.5),4*i), Size2 = VT(5*i,0,5*i), Transparency = 0, Transparency2 = 1, CFrame = CF(POS)*ANGLES(0,360*math.rad(i),0), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		ApplyAoE(POS,20,true)
		attacks:hitbox(20,POS)
	end
end

function Stomp()
	ATTACK = true
	Rooted = false
	PLAYANIMS = false
	Speed = 5
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 2 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1*SIZE, -0.4*SIZE, -0.6*SIZE) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE /12), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
	end
	CreateSound(3923230963,Torso,10,1,false)
	WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(50,10,50)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = "rbxassetid://3923230963", SoundPitch = MRANDOM(1,1.1), SoundVolume = 10})
	WACKYEFFECT({Time = 25, EffectType = "Block2", Size = VT(0,0,0), Size2 = VT(50,50,50)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = "rbxassetid://3923230963", SoundPitch = MRANDOM(1,1.1), SoundVolume = 10})
	WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0.01,1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = "rbxassetid://3923230963", SoundPitch = MRANDOM(1,1.1), SoundVolume = 10})
	WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0.01,1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = "rbxassetid://3923230963", SoundPitch = MRANDOM(1,1.1), SoundVolume = 10})
	WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0.01,1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = "rbxassetid://3923230963", SoundPitch = MRANDOM(1,1.1), SoundVolume = 10})
	ApplyAoE(RootPart.Position,25,true)
	attacks:hitbox(25,RootPart.Position)
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 3 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-180), RAD(-5)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE /12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE /12), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE /12), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
	end
	Speed = 50
	PLAYANIMS = true
	ATTACK = false
	Rooted = false
	Humanoid.CameraOffset = VT(0,0,0)
end

function Slash()
	ATTACK = true
	Rooted = true
	PLAYANIMS = false
	local STOPPP = false
	MagicSphere(VT(0,0,0),15,RootPart.CFrame,"Really black",VT(2,2,2))
	coroutine.wrap(function()
		while wait() do
			WACKYEFFECT({Time = 15, EffectType = "Crystal", Size = VT(1,5,1), Size2 = VT(1,25,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,0,0)*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Glass", Color = BRICKC"Really red".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			if STOPPP == true then
				break
			end
		end
	end)()
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		CreateRing(VT(0,0,0),false,0,5,CF(RootPart.Position-VT(0,3,0))*ANGLES(RAD(90),RAD(0),RAD(0)),"Really black",VT(1,1,0))
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, -0.5*SIZE) * ANGLES(RAD(0), RAD(0), RAD(-75)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0*SIZE + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(90), RAD(-45), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-0.2*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1*SIZE, -0.5*SIZE, -0.5*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(-45), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	for i=0,0.1, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.5)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0*SIZE + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-75)), 0.5)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(90), RAD(-45), RAD(0)) * RIGHTSHOULDERC0, 0.5)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(90), RAD(0), RAD(75)) * LEFTSHOULDERC0, 0.5)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
	end
	local SOUND = CreateSound("rbxasset://sounds/swordlunge.wav", Torso, 5, 0.6)
	SOUND.SoundId = "rbxasset://sounds/swordlunge.wav"
	CreateSound(62339698, Torso, 10, 0.4)
	ApplyAoE(RootPart.Position,55,true)
	attacks:hitbox(55,RootPart.Position)
	WACKYEFFECT({Time = 25, EffectType = "Block2", Size = VT(5,5,5), Size2 = VT(100,100,100)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = "rbxassetid://3923230963", SoundPitch = MRANDOM(1,1.1), SoundVolume = 10})
	WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0,1)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-4,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0,1)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-4,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0,1)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-4,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	STOPPP = true
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.5)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0*SIZE + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-75)), 0.5)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(90), RAD(0), RAD(-75)) * RIGHTSHOULDERC0, 0.5)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(90), RAD(0), RAD(75)) * LEFTSHOULDERC0, 0.5)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
	end
	PLAYANIMS = true
	ATTACK = false
	Rooted = false
end

function Grab()
	local TARGET = Mouse.Target
	if TARGET ~= nil and TARGET.Parent:FindFirstChildOfClass("Humanoid") then
		do
			local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
			local ROOT = GetRoot(HUM.Parent, true)
			local FOE = ROOT.Parent
			local HED = FOE:FindFirstChild("Head")
			local TORS = FOE:FindFirstChild("Torso") or FOE:FindFirstChild("UpperTorso")
			Rooted = true
			turnto(TORS.Position)
			if ROOT and HUM.Health > 0 then   
				ATTACK = true	
				coroutine.resume(coroutine.create(function()
					repeat
						Swait()
						WACKYEFFECT({
							Time = 12,
							EffectType = "Sphere",
							Size = VT(5, 5, 5)/10,
							Size2 = VT(0, 0, 250)/10,
							Transparency = 0,
							Transparency2 = 1,
							CFrame = CF(ROOT.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
							MoveToPos = nil,
							RotationX = 0,
							RotationY = 0,
							RotationZ = 0,
							Material = "Neon",
							Color = C3(1,0,0),
							SoundID = "rbxassetid://220834019",
							SoundPitch = 2,
							SoundVolume = .5,
							UseBoomerangMath = true,
							Boomerang = 50,
							SizeBoomerang = 100
						})
						WACKYEFFECT({Time = 25, EffectType = "Box", Size = VT(2,0,2)/3, Size2 = VT(6,7.5,6)/3, Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame * ANGLES(RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360)), RAD(MRANDOM(-360,360))), MoveToPos = RightArm.CFrame*CF(0,-1,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({
							Time = 15,
							EffectType = "Box",
							Size = TORS.Size * 1.2,
							Size2 = TORS.Size * 1.2,
							Transparency = 0.4,
							Transparency2 = 1,
							CFrame = TORS.CFrame,
							MoveToPos = nil,
							RotationX = 0,
							RotationY = 0,
							RotationZ = 0,
							Material = "Neon",
							Color = C3(1, 0, 0),
							SoundID = nil,
							SoundPitch = nil,
							SoundVolume = nil,
							UseBoomerangMath = false,
							Boomerang = 0,
							SizeBoomerang = 0
						})
						RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
						Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-2), RAD(-5), RAD(-85)) * ANGLES(RAD(0), RAD(0), RAD(-22 - 2.5 * SIN(SINE / 13))), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.65, 1, 0) * ANGLES(RAD(120), RAD(0), RAD(90))* RIGHTSHOULDERC0, 0.15 / 3)
						LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.85, .5, 0) * ANGLES(RAD(0),RAD(0),RAD(-50)) * ANGLES(RAD(0),RAD(0),RAD(MRANDOM(-10,40))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
						RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
						LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					until ATTACK == false
				end))
				HUM.Health = .11111
				HUM:SetStateEnabled("Dead",true)
				local POS = ROOT.Position + VT(0, 15 * ROOT.Size.Z, 0)
				local grav = Instance.new("BodyPosition", ROOT)
				grav.D = 850
				grav.P = 4000
				grav.maxForce = VT(9e9,9e9,9e9)
				grav.Position = POS
				wait(2)
				Kill(TARGET.Parent)
				ATTACK = false
				Rooted = false
				Humanoid.CameraOffset = VT(0,0,0)
			end
		end	
	end
end

function beam2()
	ATTACK = true
	Rooted = false
	for i=0,2,.5 / Animation_Speed do
		spawnwave(Mouse.Hit.p)
	end
	ATTACK = false
	Rooted = false
end

function switch()
	ATTACK = true
	Rooted = false
	if mde == "Corrupt" then
		CreateSound(147722227, Torso, 10, 1.3, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(-15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.2) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end

		WACKYEFFECT({Time = 50, EffectType = "Block2", Size = VT(2.5,2.5,2.5), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val,val,val), SoundID = nil, SoundPitch = 1, SoundVolume = 4})
		for i=0, 0.8, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.15, 0.5, 0.5) * ANGLES(RAD(-35 - 4 * COS(SINE / 12)), RAD(0), RAD(45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Speed = 40
		mde = "Relaxed"
		sick.SoundId = "rbassetid://709100631"
	elseif mde == "Relaxed" then
		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif mde == "kick" then
		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-80)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(0), RAD(0), RAD(80)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(-25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Speed = 20
		mde = "Corrupt"
		sick.SoundId = "rbxassetid://207790293"
	end
	ATTACK = false
	Rooted = false
end

function switch2()
	ATTACK = true
	Rooted = true
	if mde == "Corrupt" then
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(-25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(-25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(-25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(-25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(-25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(-25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end


		Speed = 80
		mde = "Insanity"
		sick.SoundId = "rbxassetid://2297862957"
	elseif mde == "Insanity" then
		CreateSound(147722227, Torso, 10, 1.3, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(-15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.2) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end


		WACKYEFFECT({Time = 50, EffectType = "Block2", Size = VT(2.5,2.5,2.5), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val,val,val), SoundID = nil, SoundPitch = 1, SoundVolume = 4})
		for i=0, 0.8, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.15, 0.5, 0.5) * ANGLES(RAD(-35 - 4 * COS(SINE / 12)), RAD(0), RAD(45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Speed = 20
		mde = "Corrupt"
		sick.SoundId = "rbxassetid://1416035124"
	end
	ATTACK = false
	Rooted = false
end

function switch3()
	ATTACK = true
	Rooted = false
	if mde == "Corrupt" then
		CreateSound(147722227, Torso, 10, 1.3, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(-15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.2) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end

		WACKYEFFECT({Time = 50, EffectType = "Block2", Size = VT(2.5,2.5,2.5), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val,val,val), SoundID = nil, SoundPitch = 1, SoundVolume = 4})
		for i=0, 0.8, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.15, 0.5, 0.5) * ANGLES(RAD(-35 - 4 * COS(SINE / 12)), RAD(0), RAD(45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Speed = 100
		mde = "Vis"
		sick.SoundId = "rbxassetid://2493434541"
	elseif mde == "Vis" then
		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-80)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(0), RAD(0), RAD(80)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(-25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Speed = 20
		mde = "Corrupt"
		sick.SoundId = "rbxassetid://1416035124"
	end
	ATTACK = false
	Rooted = false
end

function switch4()
	ATTACK = true
	Rooted = false
	if mde == "Corrupt" then
		CreateSound(147722227, Torso, 10, 1.3, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(-15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.2) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end

		WACKYEFFECT({Time = 50, EffectType = "Block2", Size = VT(2.5,2.5,2.5), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val,val,val), SoundID = nil, SoundPitch = 1, SoundVolume = 4})
		for i=0, 0.8, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.15, 0.5, 0.5) * ANGLES(RAD(-35 - 4 * COS(SINE / 12)), RAD(0), RAD(45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Speed = 50
		mde = "Sit"
		sick.SoundId = 2977420748
	elseif mde == "Sit" then	

		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-80)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(0), RAD(0), RAD(80)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(-25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Speed = 20
		mde = "Corrupt"
		sick.SoundId = "rbxassetid://1416035124"
	end
	ATTACK = false
	Rooted = false
end

function switch5()
	ATTACK = true
	Rooted = false
	if mde == "Corrupt" then
		CreateSound(147722227, Torso, 10, 1.3, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(-15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.2) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end

		WACKYEFFECT({Time = 50, EffectType = "Block2", Size = VT(2.5,2.5,2.5), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val,val,val), SoundID = nil, SoundPitch = 1, SoundVolume = 4})
		for i=0, 0.8, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.15, 0.5, 0.5) * ANGLES(RAD(-35 - 4 * COS(SINE / 12)), RAD(0), RAD(45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Speed = 70
		mde = "error"
		sick.SoundId = "rbxassetid://3269680589"
	elseif mde == "error" then

		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-80)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(0), RAD(0), RAD(80)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound(363808674, Torso, 10, 1, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(-25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Speed = 20
		mde = "Corrupt"
		sick.SoundId = "rbxassetid://1416035124"
	end
	ATTACK = false
	Rooted = false
end

function itsman()
	ATTACK = true
	Rooted = false
	local GYRO = IT("BodyGyro",RootPart)
	GYRO.D = 100
	GYRO.P = 2000
	GYRO.MaxTorque = VT(0,4000000,0)
	GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
	CreateSound("93724183", RightArm, 5, 1, false)
	for i=1, 35 do
		Swait()
		WACKYEFFECT({Time = 5, EffectType = "Block2", Size = VT(5,5,5), Size2 = VT(0,0,0), Transparency = 1, Transparency2 = 0.25, CFrame = RightArm.CFrame*CF(0,-5,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 0.6, SoundVolume = 6})
		GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(45)), 1 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-45 - 4 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), -0.5) * ANGLES(RAD(90), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	local BEAM = CreatePart(3, Effects, "Neon", 0, 1, "Institutional white", "Lazer", VT(0,0,0))
	local LOOP = CreateSound("155194054", Head, 5, 1, false)
	local TOCH = BEAM.Touched:Connect(function(hit)
		if hit.Anchored == false and hit.Parent ~= Head and  hit.Parent ~= Character and hit.Parent ~= Effects then
			Kill(hit)
		end
	end)
	local I = 0
	repeat
		Swait()
		I = I + 1
		if I <= 10 then
			BEAM.Transparency = BEAM.Transparency - 0.1
		end
		local STARTPOS = RightArm.CFrame*CF(0,-4,0).Position
		local ENDHIT,ENDPOS = CastProperRay(STARTPOS,Mouse.Hit.p,650,Character)
		local DISTANCE = (STARTPOS - ENDPOS).Magnitude
		BEAM.CFrame = CF(STARTPOS,ENDPOS)*CF(0,0,-DISTANCE/2)*ANGLES(RAD(0),RAD(0),RAD(I*5))
		BEAM.Size = VT(2,2,DISTANCE)
		WACKYEFFECT({Time = 5, EffectType = "Box", Size = VT(1,1,1), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(ENDPOS), MoveToPos = CF(ENDPOS)*ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)))*CF(0,15,0).p, RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 5, EffectType = "Block2", Size = VT(5,5,5), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 0.25, CFrame = RightArm.CFrame*CF(0,-4,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = 0.6, SoundVolume = 6})
		WACKYEFFECT({Time = 5, EffectType = "Block2", Size = VT(5,5,5), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 0.25, CFrame = CF(ENDPOS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = 0.6, SoundVolume = 6})
		GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(45)), 1 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-45 - 4 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), -0.5) * ANGLES(RAD(90), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		if ENDHIT ~= nil then
			if ENDHIT.Anchored == false and ENDHIT.Parent ~= Effects then
				Kill(ENDHIT)
			end
		end
	until LOOP.Playing == false
	GYRO:remove()
	BEAM:remove()
	ATTACK = false
	Rooted = false
end

function PoisonedTaunt()
	ATTACK = true
	Rooted = false
	chatfunc("I  n e e d  a  c u r e")
	CreateSound(155194054, Torso, 2, 1, false)
	for i=1, 170 do
		Swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(MRANDOM(-45,45))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(20), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(20), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.25 * COS(sine / 12), -0.01) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.25 * COS(sine / 12), -0.01) * ANGLES(RAD(20), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function switch6()
	ATTACK = true
	Rooted = true
	if mde == "Corrupt" then
		for i=1, 333 / Animation_Speed do
			Swait()
			WACKYEFFECT({TIME = 56, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),-2.5,MRANDOM(-4,4))), MoveToPos = Torso.Position*VT(MRANDOM(-9,9),2,MRANDOM(-9,9)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({TIME = 23, EffectType = "Wave", Size = VT(6 + 2 * COS(SINE/4),4 + 2 * COS(SINE/4),6 + 2 * COS(SINE/4)), Size2 = VT(11,4,11), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(0,2.5,0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({TIME = 56, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(15,15,15), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(0,0,0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, -1.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(-15), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1, 0.5, -0.6) * ANGLES(RAD(165), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1, 0.5, -0.6) * ANGLES(RAD(165), RAD(0), RAD(50)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, 0.5, -0.75) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1, -0.4) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(5), RAD(0), RAD(90)), 0.5 / Animation_Speed)
		end
		WACKYEFFECT({TIME = 435, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),7 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),0,MRANDOM(-4,4)))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = Torso.Position*VT(MRANDOM(-54,54),MRANDOM(-54,54),MRANDOM(-54,54)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({TIME = 453, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),7 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),0,MRANDOM(-4,4)))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = Torso.Position*VT(MRANDOM(-54,54),MRANDOM(-54,54),MRANDOM(-54,54)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({TIME = 453, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),7 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),0,MRANDOM(-4,4)))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = Torso.Position*VT(MRANDOM(-54,54),MRANDOM(-54,54),MRANDOM(-54,54)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({TIME = 443, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),7 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),0,MRANDOM(-4,4)))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = Torso.Position*VT(MRANDOM(-54,54),MRANDOM(-54,54),MRANDOM(-54,54)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({TIME = 564, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),7 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),0,MRANDOM(-4,4)))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = Torso.Position*VT(MRANDOM(-54,54),MRANDOM(-54,54),MRANDOM(-54,54)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

		mde = 'nebula'
		sick.SoundId = 1138324365
		Speed = 16
	elseif mde == 'nebula' then
		for i=1, 660 / Animation_Speed do
			Swait()
			WACKYEFFECT({TIME = 56, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(15,15,15), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(0,0,0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(60), RAD(0)) * ANGLES(RAD(-11), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-11), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		WACKYEFFECT({TIME = 435, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),7 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),0,MRANDOM(-4,4)))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = Torso.Position*VT(MRANDOM(-54,54),MRANDOM(-54,54),MRANDOM(-54,54)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({TIME = 453, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),7 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),0,MRANDOM(-4,4)))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = Torso.Position*VT(MRANDOM(-54,54),MRANDOM(-54,54),MRANDOM(-54,54)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({TIME = 453, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),7 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),0,MRANDOM(-4,4)))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = Torso.Position*VT(MRANDOM(-54,54),MRANDOM(-54,54),MRANDOM(-54,54)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({TIME = 443, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),7 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),0,MRANDOM(-4,4)))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = Torso.Position*VT(MRANDOM(-54,54),MRANDOM(-54,54),MRANDOM(-54,54)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({TIME = 564, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),7 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),0,MRANDOM(-4,4)))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = Torso.Position*VT(MRANDOM(-54,54),MRANDOM(-54,54),MRANDOM(-54,54)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({TIME = 435, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),7 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),0,MRANDOM(-4,4)))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = Torso.Position*VT(MRANDOM(-54,54),MRANDOM(-54,54),MRANDOM(-54,54)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({TIME = 453, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),7 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),0,MRANDOM(-4,4)))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = Torso.Position*VT(MRANDOM(-54,54),MRANDOM(-54,54),MRANDOM(-54,54)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({TIME = 453, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),7 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),0,MRANDOM(-4,4)))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = Torso.Position*VT(MRANDOM(-54,54),MRANDOM(-54,54),MRANDOM(-54,54)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({TIME = 443, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),7 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),0,MRANDOM(-4,4)))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = Torso.Position*VT(MRANDOM(-54,54),MRANDOM(-54,54),MRANDOM(-54,54)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({TIME = 564, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),7 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-4,4),0,MRANDOM(-4,4)))*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = Torso.Position*VT(MRANDOM(-54,54),MRANDOM(-54,54),MRANDOM(-54,54)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "ForceField", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		mde = "Corrupt"
		sick.SoundId = "rbxassetid://1416035124"
		Speed = 20
	end
	ATTACK = false
	Rooted = false
end

function modetoggle()
	if mde == "Corrupt" then
		mde = "Relaxed"
		ModeVal.Value = "Relaxed"
		sick.SoundId = 'rbxassetid://709100631'
		CreateSound(155202884, Torso, 2, 1.4, false)
		local POS = RootPart.Position
		for i = 1, 5 do
			WACKYEFFECT({
				Time = 25,
				EffectType = "Sphere",
				Size = VT(2, 2, 2),
				Size2 = VT(0, 0, 500),
				Transparency = 1,
				Transparency2 = 0,
				CFrame = CF(POS),
				MoveToPos = nil,
				RotationX = MRANDOM(-2, 2),
				RotationY = MRANDOM(-12, 12),
				RotationZ = MRANDOM(-2, 2),
				Material = "Neon",
				Color = C3(),
				SoundID = nil,
				SoundPitch = nil,
				SoundVolume = nil
			})
		end
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(30,30,30), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(), SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		mde = "Relaxed"
		ModeVal.Value = "Relaxed"
		sick.SoundId = 'rbxassetid://709100631'
		sick.PlaybackSpeed = 1
		TauntRemote:FireServer(""..mde,709100631,sick.TimePosition,sick.Pitch)
		Speed = 40
	elseif mde == "Relaxed" then
		CreateSound(155202884, Torso, 2, 1.4, false)
		local POS = RootPart.Position
		for i = 1, 5 do
			WACKYEFFECT({
				Time = 25,
				EffectType = "Sphere",
				Size = VT(2, 2, 2),
				Size2 = VT(0, 0, 500),
				Transparency = 1,
				Transparency2 = 0,
				CFrame = CF(POS),
				MoveToPos = nil,
				RotationX = MRANDOM(-2, 2),
				RotationY = MRANDOM(-12, 12),
				RotationZ = MRANDOM(-2, 2),
				Material = "Neon",
				Color = RightArm.Color,
				SoundID = nil,
				SoundPitch = nil,
				SoundVolume = nil
			})
		end
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(30,30,30), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = RightArm.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		mde = "Vis"
		ModeVal.Value = "Vis"
		if TypeOfMode == "Godcat" then
			sick.SoundId = 'rbxassetid://6736840454'
			TauntRemote:FireServer(""..mde,6736840454,3,1.1)
			sick.PlaybackSpeed = 1
		elseif TypeOfMode == "LC" then
			sick.SoundId = 'rbxassetid://758186003'
			sick.Pitch = 1
			TauntRemote:FireServer(""..mde,758186003,sick.TimePosition,sick.Pitch)
		end
		Speed = 100
	elseif mde == "Vis" then
		CreateSound(155202884, Torso, 2, 1.4, false)
		local POS = RootPart.Position
		for i = 1, 5 do
			WACKYEFFECT({
				Time = 25,
				EffectType = "Sphere",
				Size = VT(2, 2, 2),
				Size2 = VT(0, 0, 500),
				Transparency = 1,
				Transparency2 = 0,
				CFrame = CF(POS),
				MoveToPos = nil,
				RotationX = MRANDOM(-2, 2),
				RotationY = MRANDOM(-12, 12),
				RotationZ = MRANDOM(-2, 2),
				Material = "Neon",
				Color = RightArm.Color,
				SoundID = nil,
				SoundPitch = nil,
				SoundVolume = nil
			})
		end
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(30,30,30), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = RightArm.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		mde = "Sit"
		ModeVal.Value = "Sit"
		sick.SoundId = 'rbxassetid://3727388982'
		sick.PlaybackSpeed = 1
		Speed = 80
		TauntRemote:FireServer(""..mde,6736840454,sick.TimePosition,sick.Pitch)
	elseif mde == "Sit" then
		mainIntro()
		mde = "Undesired"
		sick.SoundId = "rbxassetid://6669026731"
		sick.PlaybackSpeed = 1.1
		sick.TimePosition = 0
		Speed = 56
		TauntRemote:FireServer(""..mde,6669026731,sick.TimePosition,sick.Pitch)
	elseif mde == "Undesired" then
		mde = "LCV2Mode5"
		sick.SoundId = "rbxassetid://213821591"
		sick.PlaybackSpeed = 1
		sick.TimePosition = 0
		Speed = 16
		TauntRemote:FireServer(""..mde,213821591,sick.TimePosition,sick.Pitch)
	elseif mde == "LCV2Mode5" then
		WACKYEFFECT({Time = 25,EffectType = "Block2", Size = VT(0,0,0), Size2 = VT(25,25,25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MRANDOM(1,360), RotationY = MRANDOM(1,360), RotationZ = MRANDOM(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = "rbxassetid://260435136", SoundPitch = 0.9, SoundVolume = 10})
		WACKYEFFECT({Time = 12.5,EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(0.25,0,0.25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MRANDOM(1,360), RotationY = MRANDOM(1,360), RotationZ = MRANDOM(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12.5,EffectType = "Ring", Size = VT(0,0,0), Size2 = VT(1.25,2.5,2.5), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MRANDOM(1,360), RotationY = MRANDOM(1,360), RotationZ = MRANDOM(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12.5,EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(25,0,25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MRANDOM(1,360), RotationY = MRANDOM(1,360), RotationZ = MRANDOM(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		mde = "Echo"
		sick.SoundId = "rbxassetid://880201065"
		sick.PlaybackSpeed = 1
		sick.TimePosition = 0
		Speed = 50
		TauntRemote:FireServer(""..mde,880201065,sick.TimePosition,sick.Pitch)
	elseif mde == "Echo" then	
		CreateSound(155202884, Torso, 2, 1.4, false)
		local POS = RootPart.Position
		for i = 1, 5 do
			WACKYEFFECT({
				Time = 25,
				EffectType = "Sphere",
				Size = VT(2, 2, 2),
				Size2 = VT(0, 0, 500),
				Transparency = 1,
				Transparency2 = 0,
				CFrame = CF(POS),
				MoveToPos = nil,
				RotationX = MRANDOM(-2, 2),
				RotationY = MRANDOM(-12, 12),
				RotationZ = MRANDOM(-2, 2),
				Material = "Neon",
				Color = RightArm.Color,
				SoundID = nil,
				SoundPitch = nil,
				SoundVolume = nil
			})
		end
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(30,30,30), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = RightArm.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(30,30,30), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = RightArm.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
		mde = "Corrupt"
		ModeVal.Value = "Corrupt"
		if TypeOfMode == "Godcat" then
			sick.SoundId = "rbxassetid://5999157245"
			TauntRemote:FireServer(""..mde,5999157245,sick.TimePosition,sick.Pitch)
			sick.PlaybackSpeed = 1
		else if TypeOfMode == "LC" then
				sick.SoundId = "rbxassetid://6276736821"
				sick.PlaybackSpeed = 1
				TauntRemote:FireServer(""..mde,6276736821,sick.TimePosition,sick.Pitch)
			end
		end
		Speed = 20
	end
end

local States = {"FallingDown","PlatformStanding","Physics","Swimming","Dead","Ragdoll","Seated"}
for i,v in pairs(States) do Humanoid:SetStateEnabled(v,false) end
--//=================================\\
--||        CHAT FUNCTION
--\\=================================//
function chatfunc(text)
	if string.sub(text,1,3) == "/e " or string.sub(text,1,3) == "/w " or string.sub(text,1,3) == "/c " or string.sub(text,1,8) == "/console"  or string.sub(text,1,6) == "/clear" then
		return
	end
	local chat = coroutine.wrap(function()
		if Character:FindFirstChild("TalkingBillBoard")~= nil then
			Character:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local Bill = Instance.new("BillboardGui",Character)
		Bill.Size = UDim2.new(0,100,0,40)
		Bill.StudsOffset = Vector3.new(0,3,0)
		Bill.Adornee = Character.Head
		Bill.Name = "TalkingBillBoard"
		local Hehe = Instance.new("TextLabel",Bill)
		Hehe.BackgroundTransparency = 1
		Hehe.BorderSizePixel = 0
		Hehe.Text = ""
		Hehe.Font = "Arcade"
		Hehe.TextSize = 40
		Hehe.TextStrokeTransparency = 0
		Hehe.Size = UDim2.new(1,0,0.5,0)
		coroutine.resume(coroutine.create(function()
			while Hehe ~= nil do
				Swait()	
				Hehe.Position = UDim2.new(0,math.random(-1.5,1.5),0,math.random(-1.5,1.5))	
				Hehe.Rotation = 0-2*math.random(-1.5,1.5)
				if mde == "Corrupt" or mde == "uxi" then
					Hehe.TextColor3 = Color3.fromRGB(val,0,0)
					Hehe.TextStrokeColor3 = Color3.fromRGB(val,0,0)
				elseif mde == 'Insanity' or mde == 'krma' or mde == 'asi' then
					Hehe.TextColor3 = BrickColor.Random().Color
					Hehe.TextStrokeColor3 = BrickColor.Random().Color
				elseif mde == "Vis" or mde == 'poisoned' or mde == 'ao' then
					Hehe.TextColor3 = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
					Hehe.TextStrokeColor3 = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
				elseif mde == "Sit" then
					Hehe.TextColor3 = Color3.fromHSV(Hue/360,1,math.clamp(sick.PlaybackLoudness/950,0,1))
					Hehe.TextStrokeColor3 = Color3.fromHSV(Hue/360,1,math.clamp(sick.PlaybackLoudness/950,0,1))
				elseif mde == "error" or mde == "Meme" then
					Hehe.TextColor3 = Color3.fromRGB(0,math.random(0,255),0)
					Hehe.TextStrokeColor3 = Color3.fromRGB(0,math.random(0,255),0)
				elseif mde == 'nebula' or mde == 'edgialization' then
					Hehe.TextColor3 = Color3.fromRGB(math.random(0,255),0,0)
					Hehe.TextStrokeColor3 = Color3.fromRGB(math.random(0,255),0,0)
				elseif mde == "val" then
					Hehe.TextColor3 = Color3.fromRGB(math.random(0,255),255,255)
					Hehe.TextStrokeColor3 = Color3.fromRGB(math.random(0,255),255,255)
				elseif mde == "???" then
					Hehe.TextColor3 = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
					Hehe.TextStrokeColor3 = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
				elseif mde == 'Rev' or mde == 'unholy' then
					Hehe.TextColor3 = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0)
					Hehe.TextStrokeColor3 = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0)
				elseif mde == 'mnlght' then
					Hehe.TextColor3 = Color3.fromRGB(0,0+89*sick.PlaybackLoudness/100,0+18*sick.PlaybackLoudness/100)
					Hehe.TextStrokeColor3 = Color3.fromRGB(0,0+89*sick.PlaybackLoudness/100,0+18*sick.PlaybackLoudness/100)
				elseif mde == 'death' or mde == 'kick' or mde == 'val' then
					Hehe.TextColor3 = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000)
					Hehe.TextStrokeColor3 = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000)
				elseif mde == 'uncolored' or mde == 'unknown' or mde == 'depressed' then
					Hehe.TextColor3 = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
					Hehe.TextStrokeColor3 = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
				end	
			end
		end))
		for i = 1,string.len(text),1 do
			Swait(4)
			Hehe.Text = string.sub(text,1,i)
		end
		Swait(30)
		local rrot = math.random(1,2)
		if rrot == 1 then
			for i = 1, 100 do
				swait()
				Hehe.Position = Hehe.Position - UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))
				Hehe.Rotation = Hehe.Rotation - .8
				Hehe.TextStrokeTransparency = Hehe.TextStrokeTransparency +.02
				Hehe.TextTransparency = Hehe.TextTransparency + .02
			end
		elseif rrot == 2 then
			for i = 1, 100 do
				swait()
				Hehe.Position = Hehe.Position - UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))
				Hehe.Rotation = Hehe.Rotation - .8
				Hehe.TextStrokeTransparency = Hehe.TextStrokeTransparency +.02
				Hehe.TextTransparency = Hehe.TextTransparency + .02
			end
		end
		Bill:Destroy()
	end)
	chat()
end

function chatfuncy(text)
	local chat = coroutine.wrap(function()
		if Character:FindFirstChild("TalkingBillBoard")~= nil then
			Character:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local Bill = Instance.new("BillboardGui",Character)
		Bill.Size = UDim2.new(0,100,0,40)
		Bill.StudsOffset = Vector3.new(0,3,0)
		Bill.Adornee = Character.Head
		Bill.Name = "TalkingBillBoard"
		local Hehe = Instance.new("TextLabel",Bill)
		Hehe.BackgroundTransparency = 1
		Hehe.BorderSizePixel = 0
		Hehe.Text = ""
		Hehe.Font = "Garamond"
		Hehe.TextSize = 40
		Hehe.TextStrokeTransparency = 0
		Hehe.Size = UDim2.new(1,0,0.5,0)
		coroutine.resume(coroutine.create(function()
			while Hehe ~= nil do
				Swait()	
				Hehe.Position = UDim2.new(0,math.random(-1.5,1.5),0,math.random(-1.5,1.5))	
				Hehe.Rotation = 0-2*math.random(-1.5,1.5)
				if mde == "Corrupt" or mde == "uxi" then
					Hehe.TextColor3 = Color3.fromRGB(val,val,val)
					Hehe.TextStrokeColor3 = Color3.fromRGB(val,val,val)
				elseif mde == 'Insanity' or mde == 'krma' or mde == 'asi' then
					Hehe.TextColor3 = BrickColor.Random().Color
					Hehe.TextStrokeColor3 = BrickColor.Random().Color
				elseif mde == "Vis" or mde == 'poisoned' or mde == 'ao' then
					Hehe.TextColor3 = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
					Hehe.TextStrokeColor3 = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
				elseif mde == "Sit" then
					Hehe.TextColor3 = Color3.fromHSV(Hue/360,1,math.clamp(sick.PlaybackLoudness/950,0,1))
					Hehe.TextStrokeColor3 = Color3.fromHSV(Hue/360,1,math.clamp(sick.PlaybackLoudness/950,0,1))
				elseif mde == "error" or mde == "Meme" then
					Hehe.TextColor3 = Color3.fromRGB(0,math.random(0,255),0)
					Hehe.TextStrokeColor3 = Color3.fromRGB(0,math.random(0,255),0)
				elseif mde == 'nebula' or mde == 'edgialization' then
					Hehe.TextColor3 = Color3.fromRGB(math.random(0,255),0,0)
					Hehe.TextStrokeColor3 = Color3.fromRGB(math.random(0,255),0,0)
				elseif mde == "val" then
					Hehe.TextColor3 = Color3.fromRGB(math.random(0,255),255,255)
					Hehe.TextStrokeColor3 = Color3.fromRGB(math.random(0,255),255,255)
				elseif mde == "???" then
					Hehe.TextColor3 = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
					Hehe.TextStrokeColor3 = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
				elseif mde == 'Rev' or mde == 'unholy' then
					Hehe.TextColor3 = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0)
					Hehe.TextStrokeColor3 = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0)
				elseif mde == 'mnlght' then
					Hehe.TextColor3 = Color3.fromRGB(0,0+89*sick.PlaybackLoudness/100,0+18*sick.PlaybackLoudness/100)
					Hehe.TextStrokeColor3 = Color3.fromRGB(0,0+89*sick.PlaybackLoudness/100,0+18*sick.PlaybackLoudness/100)
				elseif mde == 'death' or mde == 'kick' or mde == 'val' then
					Hehe.TextColor3 = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000)
					Hehe.TextStrokeColor3 = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000)
				elseif mde == 'uncolored' or mde == 'unknown' or mde == 'depressed' then
					Hehe.TextColor3 = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
					Hehe.TextStrokeColor3 = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
				end	
			end
		end))
		for i = 1,string.len(text),1 do
			Swait()
			Hehe.Text = string.sub(text,1,i)
		end
		Swait(30)
		local rrot = math.random(1,2)
		if rrot == 1 then
			Hehe.Text = ""
			CreateSound(333430981,RootPart,10,1,false)
			for i = 1, 100 do
				swait()
				Hehe.Text = "HAHAHA"
				Hehe.Position = Hehe.Position - UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))
				Hehe.Rotation = Hehe.Rotation - .8
				Hehe.TextStrokeTransparency = Hehe.TextStrokeTransparency +.02
				Hehe.TextTransparency = Hehe.TextTransparency + .02
			end
		elseif rrot == 2 then
			Hehe.Text = ""
			CreateSound(333430981,RootPart,10,1,false)
			for i = 1, 100 do
				swait()
				Hehe.Text = "HAHAHA"
				Hehe.Position = Hehe.Position - UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))
				Hehe.Rotation = Hehe.Rotation - .8
				Hehe.TextStrokeTransparency = Hehe.TextStrokeTransparency +.02
				Hehe.TextTransparency = Hehe.TextTransparency + .02
			end
		end
		Bill:Destroy()
	end)
	chat()
end

function FireArc(Part,ToLocation,AmountOfTime,Height,DoesCourontine)
	if DoesCourontine == false then
		local Direction = CFrame.new(Part.Position,ToLocation)
		local Distance = (Part.Position - ToLocation).Magnitude
		for i = 1,AmountOfTime do
			swait()
			Part.CFrame = Direction*CFrame.new(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
			Direction = Part.CFrame
		end
	elseif DoesCourontine == true then
		coroutine.resume(coroutine.create(function()
			local Direction = CFrame.new(Part.Position,ToLocation)
			local Distance = (Part.Position - ToLocation).Magnitude
			for i = 1,AmountOfTime do
				swait()
				Part.CFrame = Direction*CFrame.new(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
				Direction = Part.CFrame
			end
		end))
	end
end

function attacktwo()
	ATTACK = true
	Speed = 0
	AttackGyro()
	local gBullet = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"BullyFuck",Vector3.new())
	MakeForm(gBullet,"Ball")
	gBullet.CFrame = LeftArm.CFrame*CFrame.new(0,-1.5,0)
	CreateSound(2785493,gBullet,2,0.8)
	for i = 0,1.25,0.025 do
		swait()
		Effect({Time = math.random(35,55),EffectType = "Sphere",Size = Vector3.new(0.5,0.5,0.5),Size2 = Vector3.new(1,1,1),Transparency = 0,Transparency2 = 1,CFrame = LeftArm.CFrame*CFrame.new(0,-1.5,0),MoveToPos = LeftArm.CFrame*CFrame.new(0,-1.5,0)*CFrame.new(math.random(-10,10),math.random(-10,10),math.random(-10,10)).Position,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 50,SizeBoomerang = 50})
		gBullet.Size = gBullet.Size * 1.085
		gBullet.CFrame = LeftArm.CFrame*CFrame.new(0,-1.5,0)
		RootJoint.C0 = Clerp.LC(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-30)),0.7/3)
		Neck.C0 = Clerp.LC(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(-5 - 3 * math.cos(sine/12)),math.rad(0),math.rad(30)),1/3)
		RightShoulder.C0 = Clerp.LC(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/49)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
		LeftShoulder.C0 = Clerp.LC(LeftShoulder.C0,CFrame.new(-1.5,0.5 + 0.1 * math.cos(sine/12),-0) * CFrame.Angles(math.rad(85 - 1.5 * math.cos(sine/12)),math.rad(0 - 6 * math.cos(sine/12)),math.rad(-30 - 6 * math.cos(sine/12))) * lscp,1/3)
		RightHip.C0 = Clerp.LC(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp.LC(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp.LC(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	local bullets = {}
	for i = 1,math.random(27,41) do
		swait()
		local Bullet = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"BulletFuck",Vector3.new(0.6,0.6,0.6))
		MakeForm(Bullet,"Ball")
		Bullet.CFrame = gBullet.CFrame
		Effect({Time = math.random(5,20),EffectType = "Sphere",Size = Vector3.new(3,3,3)*math.random(-3,2),Size2 = Vector3.new(6,6,6)*math.random(-3,2),Transparency = 0.4,Transparency2 = 1,CFrame = Bullet.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 25})
		table.insert(bullets,Bullet)
	end
	local oofing = false
	for b = 1,#bullets do
		swait()
		local part,pos = Raycast(LeftArm.CFrame*CFrame.new(0,-1.5,0).Position,((Mouse.Hit.p+Vector3.new(math.random(-15,15),math.random(-7,7),math.random(-15,15))) - LeftArm.CFrame*CFrame.new(0,-1.5,0).Position),500,Character)
		coroutine.resume(coroutine.create(function()
			FireArc(bullets[b],pos,math.random(17,31),math.random(9,15),false)
			Effect({Time = math.random(25,35),EffectType = "Sphere",Size = Vector3.new(0.6,0.6,0.6),Size2 = Vector3.new(1.6,1.6,1.6),Transparency = 0,Transparency2 = 1,CFrame = bullets[b].CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 25})
			swait(math.random(55,65))
			for i = 1,3 do
				Effect({Time = math.random(45,65),EffectType = "Sphere",Size = Vector3.new(0.6,6,0.6)*math.random(-1.05,1.25),Size2 = Vector3.new(1.6,10,1.6)*math.random(-1.05,1.25),Transparency = 0,Transparency2 = 1,CFrame = bullets[b].CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 20,SizeBoomerang = 35})
			end
			for i = 0,10 do
				swait()
				bullets[b].Transparency = bullets[b].Transparency + 0.1
			end
			oofing = not oofing
			if oofing then
				mdmg(bullets[b].Position,10)
			end
			local EEEBRUHEEE = CreateSound(168513088,bullets[b],3.5,1.1,false)
			bullets[b].Transparency = 1
			EEEBRUHEEE.Ended:Connect(function()
				if stopeveryting then wait(math.huge) end
				bullets[b]:Destroy()
			end)
		end))
	end
	for i = 0,10 do
		swait()
		gBullet.Transparency = gBullet.Transparency + 0.1
	end
	gBullet:Destroy()
	Speed = 50
	ATTACK = false
end

function hedshoot()
	ATTACK = true
	Speed = 16
	CreateSound(235097614,RootPart,6,1.5,false)
	for i = 0,0.5,0.05 do
		swait()
		RootJoint.C0 = Clerp.LC(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),0.7/3)
		Neck.C0 = Clerp.LC(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1/3)
		RightShoulder.C0 = Clerp.LC(RightShoulder.C0,CFrame.new(1.25,0.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1/3)
		LeftShoulder.C0 = Clerp.LC(LeftShoulder.C0,CFrame.new(-1.25,0.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1/3)
		RightHip.C0 = Clerp.LC(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp.LC(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp.LC(GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 642890855,SoundPitch = 0.45,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = math.random(25,45),EffectType = "Sphere",Size = Vector3.new(2,100,2),Size2 = Vector3.new(6,100,6),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 45})
	Effect({Time = math.random(25,45),EffectType = "Sphere",Size = Vector3.new(3,100,3),Size2 = Vector3.new(9,100,9),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame*CFrame.new(math.random(-1,1),math.random(-1,1),-50)*CFrame.Angles(math.rad(math.random(89,91)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 45})
	mdmg(RootPart.Position,14)
	for i = 1,4 do
		RootPart.CFrame = RootPart.CFrame * CFrame.new(0,0,-25)
		mdmg(RootPart.Position,14)
		Lightning(RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).Position,RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).Position,6,25,shade,math.random(30,45),0.5,1.5,0,true,60) Lightning(RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).Position,RootPart.CFrame*CFrame.new(math.random(-2.5,2.5),math.random(-5,5),math.random(-15,15)).Position,6,25,Color3.new(0,0,1),math.random(30,45),0.5,1.5,0,true,60)
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(2,2,2),Size2 = Vector3.new(5,5,5),Transparency = 0,Transparency2 = 1,CFrame = RootPart.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	for i = 0,0.5,0.1 do
		swait()
		RootJoint.C0 = Clerp.LC(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90)),0.7/3)
		Neck.C0 = Clerp.LC(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-90)),1/3)
		RightShoulder.C0 = Clerp.LC(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(90)) * rscp,1/3)
		LeftShoulder.C0 = Clerp.LC(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1/3)
		RightHip.C0 = Clerp.LC(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp.LC(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp.LC(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	ATTACK = false
	Speed = 50
end

function painlessrain()
	ATTACK = true
	Speed = 16
	coroutine.wrap(function()
		for i = 0,2 do
			swait(12)
			CreateSound(199145095,Joint,10,1)
		end
	end)()
	for i = 0,2,0.1 do
		swait()
		RootJoint.C0 = Clerp.LC(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),0.7/3)
		Neck.C0 = Clerp.LC(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),1/3)
		RightShoulder.C0 = Clerp.LC(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(35),math.rad(-35),math.rad(20)) * rscp,1/3)
		LeftShoulder.C0 = Clerp.LC(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20),math.rad(-5),math.rad(-10)) * lscp,1/3)
		RightHip.C0 = Clerp.LC(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp.LC(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp.LC(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(doe * 22),math.rad(0),math.rad(0)),1/2)
	end
	for i = 0,1.5,0.1 do
		swait()
		RootJoint.C0 = Clerp.LC(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),0.7/3)
		Neck.C0 = Clerp.LC(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
		RightShoulder.C0 = Clerp.LC(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
		LeftShoulder.C0 = Clerp.LC(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
		RightHip.C0 = Clerp.LC(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp.LC(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp.LC(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Hole2.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 642890855,SoundPitch = 0.45,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Hole2.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	local skypos = Hole2.CFrame * CFrame.new(-400,0,0)
	local DISTANCE = (Hole2.Position - skypos.p).Magnitude
	local killbeam = CreatePart(3,Effects,"Neon",0,0,shade,"Kill Beam",Vector3.new(1,DISTANCE,1))
	killbeam.CFrame = CFrame.new(Hole2.Position,skypos.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
	MakeForm(killbeam,"Cyl")
	coroutine.resume(coroutine.create(function()
		for i = 1,25 do
			swait()
			killbeam.Transparency = i/25
		end
		killbeam:Destroy()
	end))
	Lightning(Hole2.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Hole2.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Hole2.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Hole2.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Hole2.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	for i = 0,2 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Hole2.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Hole2.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = "rbxassetid://192410089",SoundPitch = .55,SoundVolume = 8,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	for i = 0,2 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	for i = 0,.5,0.1 do
		swait()
		RootJoint.C0 = Clerp.LC(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),0.7/3)
		Neck.C0 = Clerp.LC(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
		RightShoulder.C0 = Clerp.LC(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(225),math.rad(-20),math.rad(20)) * rscp,1/3)
		LeftShoulder.C0 = Clerp.LC(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-5),math.rad(-5),math.rad(0)) * lscp,1/3)
		RightHip.C0 = Clerp.LC(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp.LC(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp.LC(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	for i = 0,.5,0.1 do
		swait()
		RootJoint.C0 = Clerp.LC(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),0.7/3)
		Neck.C0 = Clerp.LC(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
		RightShoulder.C0 = Clerp.LC(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
		LeftShoulder.C0 = Clerp.LC(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-5),math.rad(-5),math.rad(0)) * lscp,1/3)
		RightHip.C0 = Clerp.LC(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp.LC(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp.LC(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	ATTACK = false
	Speed = 50
	swait(36)
	local onethirdattack = 0
	for i = 1,5 do
		onethirdattack = onethirdattack + 1
		if onethirdattack >= 4 then
			onethirdattack = 1
		end
		local Sky = RootPart.CFrame*CFrame.new(0,500,0)
		local MoPos = Mouse.Hit*CFrame.new(math.random(-18,18),0,math.random(-18,18)).Position
		local DISTANCE = (Sky.p - MoPos).Magnitude
		Lightning(Sky.p,MoPos,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Sky.p,MoPos,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Sky.p,MoPos,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Sky.p,MoPos,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Sky.p,MoPos,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		local killbeam = CreatePart(3,Effects,"Neon",0,0,shade,"Kill Beam",Vector3.new(1,DISTANCE,1))
		killbeam.CFrame = CFrame.new(Sky.p,MoPos) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
		MakeForm(killbeam,"Cyl")
		coroutine.resume(coroutine.create(function()
			for i = 1,25 do
				swait()
				killbeam.Transparency = i/25
			end
			killbeam:Destroy()
		end))
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = "rbxassetid://192410089",SoundPitch = .55,SoundVolume = 8,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		for i = 0,2 do
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = CFrame.new(MoPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		end
		if onethirdattack == 3 then
			mdmg(MoPos,12)
		end
		swait(15)
	end
end
function SingularityBeam()
	ATTACK = true
	Speed = 0
	AttackGyro()
	for i = 0,0.5,0.05 do
		swait()
		RootJoint.C0 = Clerp.LC(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),0.7/3)
		Neck.C0 = Clerp.LC(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1/3)
		RightShoulder.C0 = Clerp.LC(RightShoulder.C0,CFrame.new(1.25,0.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1/3)
		LeftShoulder.C0 = Clerp.LC(LeftShoulder.C0,CFrame.new(-1.25,0.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1/3)
		RightHip.C0 = Clerp.LC(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp.LC(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp.LC(GunJoint.C0,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	local HoleDist = (Hole1.Position - Hole2.Position).Magnitude
	local chargebeam = CreatePart(3,Effects,"Neon",0,0,shade,"Charge Beam",Vector3.new(.25,HoleDist,.25),false)
	MakeForm(chargebeam,"Cyl")
	chargebeam.CFrame = CFrame.new(Hole1.Position,Hole2.Position) * CFrame.new(0,0,-HoleDist/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
	local chargeweld = weldBetween(Joint,chargebeam)
	local chargeball = CreatePart(3,Effects,"Neon",0,0,shade,"Charge Ball",Vector3.new(.5,.5,.5),false)
	chargeball.Shape = "Ball"
	chargeball.CFrame = Hole2.CFrame
	weldBetween(Hole2,chargeball)
	CreateSound(342793847,Hole1,10,1,false)
	local bigball = game:GetService("TweenService"):Create(chargeball,TweenInfo.new(3.86,Enum.EasingStyle.Linear),{Size = Vector3.new(2.5,2.5,2.5)})
	bigball:Play()
	bigball.Completed:Wait()
	chargebeam:Destroy()
	local KillDist = (Hole2.Position - Mouse.Hit.p).Magnitude
	coroutine.resume(coroutine.create(function()
		repeat if stopeveryting then wait(math.huge) end KillDist = (Hole2.Position - Mouse.Hit.p).Magnitude Swait() until ATTACK == false
	end))
	local killbeam = CreatePart(3,Effects,"Neon",0,0,shade,"Kill Beam",Vector3.new(2.5,KillDist,2.5))
	MakeForm(killbeam,"Cyl")
	killbeam.Touched:Connect(function(victim)
		if stopeveryting then wait(math.huge) end
		mdmg(victim.Position,5)
	end)
	coroutine.resume(coroutine.create(function()
		while not stopeveryting and killbeam:IsDescendantOf(game) do
			mdmg(Mouse.Hit.p,5)
			Swait(6)
		end
	end))
	coroutine.resume(coroutine.create(function()
		local isdoingathing = false
		while not stopeveryting and killbeam:IsDescendantOf(game) do
			isdoingathing = not isdoingathing
			RootPart.CFrame = RootPart.CFrame * CFrame.new(0,0,.1)
			killbeam.Size = Vector3.new(2.5,KillDist,2.5)
			killbeam.CFrame = CFrame.new(Hole2.Position,Mouse.Hit.p) * CFrame.new(0,0,-KillDist/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
			if isdoingathing then
				Lightning(Hole2.Position,Mouse.Hit.p,15,3,Color3.new(0,0,1),10,0,1,0,true,55)
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Hole2.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Hole2.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
				Effect({Time = 10,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
				Effect({Time = 10,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
				Effect({Time = 10,EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
			end
			Swait()
		end
	end))
	CreateSound(138677306,Hole2,10,1,false)
	CreateSound(415700134,Hole2,10,1,false)
	Swait(150)
	CreateSound(3264923,Hole2,10,1,false)
	Swait(30)
	chargeball:Destroy()
	killbeam:Destroy()
	Speed = 50
	ATTACK = false
end

function attackone()
	ATTACK = true
	AttackGyro()
	for i = 0,0.5,0.05 do
		swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)),0.7/3)
		Neck.C0 = Clerp.OG(Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-30)),1/3)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(30)) * rscp,1/3)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(0)) * lscp,1/3)
		RightHip.C0 = Clerp.OG(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp.OG(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp.OG(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Hole2.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 642890855,SoundPitch = 0.45,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Hole2.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	local DISTANCE = (Hole2.Position - Mouse.Hit.p).Magnitude
	local killbeam = CreatePart(3,Effects,"Neon",0,0,shade,"Kill Beam",Vector3.new(1,DISTANCE,1))
	killbeam.CFrame = CFrame.new(Hole2.Position,Mouse.Hit.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
	MakeForm(killbeam,"Cyl")
	coroutine.resume(coroutine.create(function()
		for i = 1,25 do
			swait()
			killbeam.Transparency = i/25
		end
		killbeam:Destroy()
	end))
	Lightning(Hole2.Position,Mouse.Hit.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Hole2.Position,Mouse.Hit.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Hole2.Position,Mouse.Hit.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Hole2.Position,Mouse.Hit.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	Lightning(Hole2.Position,Mouse.Hit.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
	for i = 0,2 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Hole2.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Hole2.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = "rbxassetid://192410089",SoundPitch = .55,SoundVolume = 8,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
	for i = 0,2 do
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
	end
	mdmg(Mouse.Hit.p,10)
	for i = 0,0.5,0.075 do
		swait()
		RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)),0.7/3)
		Neck.C0 = Clerp.OG(Neck.C0,NECKC0 * CFrame.new() * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-60)),1/3)
		RightShoulder.C0 = Clerp.OG(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(160),math.rad(-20),math.rad(60)) * rscp,1/3)
		LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(5)) * lscp,1/3)
		RightHip.C0 = Clerp.OG(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp.OG(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp.OG(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	ATTACK = false
end

function Ka_Boom()
	ATTACK = true
	Speed = 0
	local die = CreateSound(1566051529,RootPart,3,1)
	die.EmitterSize = 100
	swait(5)
	for i = 1,3 do
		for i = 0,1.5,0.1 do
			swait()
			RootJoint.C0 = Clerp.LC(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),0.7/3)
			Neck.C0 = Clerp.LC(Neck.C0,nc0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-5)),1/3)
			RightShoulder.C0 = Clerp.LC(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
			LeftShoulder.C0 = Clerp.LC(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
			RightHip.C0 = Clerp.LC(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
			LeftHip.C0 = Clerp.LC(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
			GunJoint.C0 = Clerp.LC(GunJoint.C0,CFrame.new(0.05,-1,-0.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		end
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Hole2.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 642890855,SoundPitch = 0.45,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = Hole2.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		local skypos = Hole2.CFrame * CFrame.new(-400,0,0)
		local DISTANCE = (Hole2.Position - skypos.p).Magnitude
		local killbeam = CreatePart(3,Effects,"Neon",0,0,shade,"Kill Beam",Vector3.new(1,DISTANCE,1))
		killbeam.CFrame = CFrame.new(Hole2.Position,skypos.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
		MakeForm(killbeam,"Cyl")
		coroutine.resume(coroutine.create(function()
			for i = 1,25 do
				swait()
				killbeam.Transparency = i/25
			end
			killbeam:Destroy()
		end))
		Lightning(Hole2.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Hole2.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Hole2.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Hole2.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		Lightning(Hole2.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
		for i = 0,2 do
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Hole2.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = Hole2.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		end
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = "rbxassetid://192410089",SoundPitch = .55,SoundVolume = 8,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		Effect({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
		for i = 0,2 do
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
			Effect({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
		end
		for i = 1,42 do
			swait()
			RootJoint.C0 = Clerp.LC(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),0.7/3)
			Neck.C0 = Clerp.LC(Neck.C0,NECKC0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
			RightShoulder.C0 = Clerp.LC(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
			LeftShoulder.C0 = Clerp.LC(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
			RightHip.C0 = Clerp.LC(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
			LeftHip.C0 = Clerp.LC(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
			GunJoint.C0 = Clerp.LC(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		end
	end
	for i = 1,15 do
		swait()
		RootJoint.C0 = Clerp.LC(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),0.7/3)
		Neck.C0 = Clerp.LC(Neck.C0,NECKC0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
		RightShoulder.C0 = Clerp.LC(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
		LeftShoulder.C0 = Clerp.LC(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
		RightHip.C0 = Clerp.LC(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp.LC(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp.LC(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
	end
	local BEAM = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"Beam",Vector3.new())
	local BEAM2 = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"Beam",Vector3.new())
	MakeForm(BEAM,"Ball")
	MakeForm(BEAM2,"Ball")
	BEAM.CFrame = CFrame.new(RootPart.Position)
	BEAM2.CFrame = CFrame.new(RootPart.Position)
	local boooom = CreateSound(415700134,RootPart,10,1,false)
	boooom.EmitterSize = 100
	for i=1,140 do
		swait()
		RootJoint.C0 = Clerp.LC(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),0.7/3)
		Neck.C0 = Clerp.LC(Neck.C0,NECKC0 * CFrame.new(0,0,0 + ((1) - 1)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
		RightShoulder.C0 = Clerp.LC(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
		LeftShoulder.C0 = Clerp.LC(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
		RightHip.C0 = Clerp.LC(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
		LeftHip.C0 = Clerp.LC(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		GunJoint.C0 = Clerp.LC(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
		BEAM.Size = BEAM.Size + Vector3.new(0.7,8,0.7)
		BEAM2.Size = BEAM2.Size + Vector3.new(2,2,2)
		BEAM.Color = NeonParts.Color
		BEAM2.Color = NeonParts.Color
		BEAM.CFrame = CFrame.new(RootPart.Position)
		BEAM2.CFrame = CFrame.new(RootPart.Position)
		WACKYEFFECT({TIME = 5+i,EffectType = "Swirl",Size = BEAM2.Size*1.15,Size2 = Vector3.new(0,BEAM.Size.Y,0),Transparency = 0.8,Transparency2 = 1,CFrame = BEAM.CFrame * CFrame.Angles(math.rad(0),math.rad(i*5),math.rad(0)),MoveToPos = nil,RotationX = 0,RotationY = i/8,RotationZ = 0,Material = "Neon",Color = NeonParts.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
	end
	mdmg(RootPart.Position,BEAM2.Size.Y/2)
	Effect({TIME = 75,EffectType = "Sphere",Size = BEAM.Size,Size2 = Vector3.new(0,BEAM.Size.Y,0),Transparency = 0,Transparency2 = 0,CFrame = BEAM.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
	Effect({TIME = 75,EffectType = "Sphere",Size = BEAM2.Size,Size2 = Vector3.new(0,0,0),Transparency = 0,Transparency2 = 0.6,CFrame = BEAM2.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = shade,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
	for i,v in pairs(Effects:GetChildren()) do
		v.Color = shade
		v:GetPropertyChangedSignal("Color"):Connect(function()
			if stopeveryting then wait(math.huge) end
			v.Color = shade
		end)
	end
	BEAM2:Destroy()
	BEAM:Destroy()
	ATTACK = false
	Speed = 50
end

Player.Chatted:Connect(function(msg)
	coroutine.resume(coroutine.create(function()
		chatfunc(msg)
	end))
end)

--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//
function MouseDown(Mouse)
	if ATTACK == false and mde == "Corrupt" or mde == "LCV2Mode5" or mde == "Echo" and TypeOfMode == "LC" then
		attackone()
	end
end

function MouseUp(Mouse)
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "z" and mde ~= "Echo" and mde ~= "LCV2Mode5" and ATTACK == false then
		shot_lol_die_minecrft_csdfbgvsdfbngjdsgvvsdfgvdfgvgfsddhijsukzc()
	end
	if Key == "n" then
		Mater = {}
		Size = {}
		Tran = {}
		Anc = {}
		CanC = {}
		Class = {}
		TOBANISH = {}
		chatfunc("Cleared Tables, Including Banish Table")
	end
	if Key == "t" and ATTACK == false then
		Taunt()
	end
	if Key == "r" then
		Funcs.characterfixer()
	end
	if Key == "u" then
		Funcs.soundfixer()
	end
	if Key == "," then
		TypeOfMode = "LC"
	end
	if Key == "." then
		TypeOfMode = "Godcat"
	end
	if Key == "p" then
		Funcs.getup()
	end
	if Key == "z" and mde == "LCV2Mode5" and ATTACK == false then	
		hedshoot()
	end
	if Key == "x" and mde == "LCV2Mode5" and ATTACK == false then
		SingularityBeam()
	end
	if Key == "c" and mde == "LCV2Mode5" and ATTACK == false then
		painlessrain()
	end
	if Key == "v" and mde == "LCV2Mode5" and ATTACK == false then
		attacktwo()
	end
	if Key == "b" and mde == "LCV2Mode5" and ATTACK == false then
		Ka_Boom()
	end
	if Key == "z" and mde == "Echo" and ATTACK == false then
		Warp()
	end
	if Key == "x" and mde == "Echo" and ATTACK == false then
		Stomp()
	end
	if Key == "c" and mde == "Echo" and ATTACK == false then
		Slash()
	end
	if Key == "v" and mde == "Echo" and ATTACK == false then
		Grab()
	end
	if Key == "b" and mde == "Echo" and ATTACK == false then
		chatfunc("Disabled cuz lag")
	end
	if Key == "e" and ATTACK == false then
		modetoggle()
	end
	if Key == "x" and mde ~= "Echo" and ATTACK == false then
		beam2()
	end
	if Key == "f" then
		ISFLYING = not ISFLYING
		sFLY()
	end
end

function KeyUp(Key)
	KEYHOLD = false
end

Mouse.Button1Down:connect(function(NEWKEY)
	MouseDown(NEWKEY)
end)
Mouse.Button1Up:connect(function(NEWKEY)
	MouseUp(NEWKEY)
end)
Mouse.KeyDown:connect(function(NEWKEY)
	KeyDown(NEWKEY)
end)
Mouse.KeyUp:connect(function(NEWKEY)
	KeyUp(NEWKEY)
end)

game:GetService("UserInputService").InputBegan:Connect(function()
	if stopeveryting then wait(math.huge) end
	if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.Space) and not alreadyfixing and game:GetService("UserInputService"):GetFocusedTextBox() == nil then 
		repeat if stopeveryting then wait(math.huge) end 
			Humanoid.Jump = true 
			game:GetService("RunService").RenderStepped:Wait() 
			Humanoid.Jump = false 
			game:GetService("RunService").RenderStepped:Wait() 
		until not game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.Space)
	end
end)
antivoid = Instance.new("Part")
antivoid.Name = randomstring()
antivoid.Size = Vector3.new(400,10,400)
antivoid.Anchored = true
antivoid.Transparency = 1
antivoid.Position = Vector3.new(RootPart.Position.X,workspace.FallenPartsDestroyHeight+5,RootPart.Position.Z)
antivoid.Parent = workspace
coroutine.resume(coroutine.create(function()
	while not stopeveryting do
		swait()
		if not alreadyfixing then
			if antivoid:IsDescendantOf(workspace) then
				antivoid.Position = Vector3.new(RootPart.Position.X,workspace.FallenPartsDestroyHeight+5,RootPart.Position.Z)
			else
				pcall(function()
					antivoid:Destroy()
				end)
				antivoid = Instance.new("Part")
				antivoid.Name = randomstring()
				antivoid.Size = Vector3.new(400,10,400)
				antivoid.Anchored = true
				antivoid.Transparency = 1
				antivoid.Position = Vector3.new(RootPart.Position.X,workspace.FallenPartsDestroyHeight+5,RootPart.Position.Z)
				antivoid.Parent = workspace
			end
		end
	end
end))

coroutine.wrap(function()
	while not stopeveryting do
		swait()
		if doe < 360 then
			doe = doe + 2
		else
			doe = 0
		end
	end
end)()

function unanchor()
	if UNANCHOR == true then
		local g = Character:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end

--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//
Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	elseif Jump == "Jump" and (Disable_Jump == false) and DOUBLED == false then
		wait(0.1)
		READYTODOUBLE = true
	end
end)
local speen = 0
coroutine.resume(coroutine.create(function()
	while true do
		Swait()
		val = MRANDOM(1,255)
		speen = speen + 0.5
		if mde == "Corrupt" then
			if TypeOfMode == "LC" then
				if MRANDOM(1,8) == 1 then
					WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				end
			elseif TypeOfMode == "Godcat" then
				local loudness = sick.PlaybackLoudness
				WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
				WACKYEFFECT({Time = 3.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
				WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			end
		elseif mde == "Undesired" then
			local loudness = sick.PlaybackLoudness
			WACKYEFFECT({Time = 3.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			WACKYEFFECT({Time = 3.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			WACKYEFFECT({Time = 3.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		elseif mde == "LCV2Mode5" then
			WACKYEFFECT({Time = 0.0000000000000000001, EffectType = "Block", Size = VT(7+sick.PlaybackLoudness/60,0.55,7+sick.PlaybackLoudness/60), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 0.000000000000000000, EffectType = "Block", Size = VT(14+sick.PlaybackLoudness/30,0.44,14+sick.PlaybackLoudness/30), Size2 = VT(10+sick.PlaybackLoudness/55,0.44,10+sick.PlaybackLoudness/55), Transparency = 0.6, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(0),RAD(-sick.PlaybackLoudness/2),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		elseif mde == "Echo" then
			local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*SIZE, Character)
			WACKYEFFECT({Time = 5, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(0.1,0,0.1)*MRANDOM(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3.25,0)*ANGLES(RAD(MRANDOM(-5,5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 10, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.1,6,0.1), Transparency = 0.3, Transparency2 = 1, CFrame = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(1,10)) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1,1)*5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), UseBoomerangMath = true, SizeBoomerang = 50, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 2.5, EffectType = "Sphere", Size = VT(1+sick.PlaybackLoudness/25,0.1,1+sick.PlaybackLoudness/25), Size2 = VT(1+sick.PlaybackLoudness/25,0.1,1+sick.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+25*sick.PlaybackLoudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		elseif mde == "Relaxed" then
			WACKYEFFECT({Time = 0.1, EffectType = "Sphere", Size = VT(3,3,3), Size2 = VT(0,0,0), Transparency = 1, Transparency2 = .25, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 0.1, EffectType = "Sphere", Size = VT(3,3,3), Size2 = VT(0,0,0), Transparency = 1, Transparency2 = .25, CFrame = LeftArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		elseif mde == "Insanity" then
			WACKYEFFECT({Time = 12, EffectType = "Block2", Size = VT(3,3,3)/3, Size2 = VT(1,1,1)/3, Transparency = .5, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		elseif mde == "Sit" then
			if MRANDOM(1,1) == 1 then
				WACKYEFFECT({Time = 0.1, EffectType = "Sphere", Size = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromHSV(Hue/360,1,math.clamp(sick.PlaybackLoudness/950,0,1)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			end	
		end
	end
end))
backupid = string.match(sick.SoundId,"%d+")
coroutine.resume(coroutine.create(function()
	while true do
		Swait()
		Humanoid.DisplayName = Funcs.NameString(tostring(ModeVal.Value))
		sick.EmitterSize = "inf"
		Cam.HeadScale = 1
		Cam.HeadLocked = true
		backupid = string.match(sick.SoundId,"%d+")
		sick.DescendantAdded:connect(function(sada)
			if sada:IsA("TremoloSoundEffect") then
				sada.Enabled = false
			end
		end)	
	end	
end))

coroutine.resume(coroutine.create(function()
	while not stopeveryting do
		for i = 0,1,(1/60) do
			swait()
			if not alreadyfixing then
				NeonParts.Color = Torso.Color
				if mde == "Corrupt" then
					Torso.Color = Color3.fromRGB(val,0,0)
					Head.Color = Color3.fromRGB(val,0,0)
					LeftArm.Color = Color3.fromRGB(val,0,0)
					RightArm.Color = Color3.fromRGB(val,0,0)
					LeftLeg.Color = Color3.fromRGB(val,0,0)
					RightLeg.Color = Color3.fromRGB(val,0,0)
				end
				if mde == "LCV2Mode5" then
					Torso.Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
					Head.Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
					LeftArm.Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
					RightArm.Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
					LeftLeg.Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
					RightLeg.Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
				end
				if mde == "Relaxed" then
					Head.Color = C3()
					LeftArm.Color = C3()
					RightArm.Color = C3()
					LeftLeg.Color = C3()
					RightLeg.Color = C3()
					Torso.Color = C3()
				end
				if mde == "Sit" then
					Head.Color = Color3.fromHSV(Hue/360,1,math.clamp(sick.PlaybackLoudness/950,0,1))
					LeftArm.Color = Color3.fromHSV(Hue/360,1,math.clamp(sick.PlaybackLoudness/950,0,1))
					RightArm.Color = Color3.fromHSV(Hue/360,1,math.clamp(sick.PlaybackLoudness/950,0,1))
					LeftLeg.Color = Color3.fromHSV(Hue/360,1,math.clamp(sick.PlaybackLoudness/950,0,1))
					RightLeg.Color = Color3.fromHSV(Hue/360,1,math.clamp(sick.PlaybackLoudness/950,0,1))
					Torso.Color = Color3.fromHSV(Hue/360,1,math.clamp(sick.PlaybackLoudness/950,0,1))
				end
				if mde == "test" or mde == "Echo" or mde == "Undesired" or mde == "Dear God" or mde == "broken"  or mde == "Snake God" or mde == "kicksher"or mde == "fuck" or mde == "guy man" or mde == "HELL" or mde == "meme" or mde == "Katana" or mde == "nightmare" or mde == "chill" or mde == "Undertail - phase 2" then
					RightArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
					LeftArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
					Torso.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
					Head.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
					LeftLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
					RightLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
				end
				if mde == "Vis" then
					Head.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/850,0,0+170*sick.PlaybackLoudness/850)
					LeftArm.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/850,0,0+170*sick.PlaybackLoudness/850)
					RightArm.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/850,0,0+170*sick.PlaybackLoudness/850)
					LeftLeg.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/850,0,0+170*sick.PlaybackLoudness/850)
					RightLeg.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/850,0,0+170*sick.PlaybackLoudness/850)
					Torso.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/850,0,0+170*sick.PlaybackLoudness/850)
				end
			end
		end
	end
end))

local ILLastFrame = tick()
while true do
	Swait()
	for T = 1, #TAIL do
		if TAIL[T] ~= nil then
			TAIL[T].C1 = Clerp.OG(TAIL[T].C1, CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(3.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		end
	end
	if mde == "Vis" then
		Character.ReverbSoundEffect.DecayTime = 1
		Character.ReverbSoundEffect.Density = 1
		Character.ReverbSoundEffect.Diffusion = 1
		Character.ReverbSoundEffect.DryLevel = -10
		Character.ReverbSoundEffect.WetLevel = 1
		Character.EqualizerSoundEffect.HighGain = 10
		Character.EqualizerSoundEffect.LowGain = 10
		Character.EqualizerSoundEffect.MidGain = -80
		Character.ChorusSoundEffect.Depth = 0
		Character.ChorusSoundEffect.Mix = 0
		Character.ChorusSoundEffect.Priority = 0
		Character.ChorusSoundEffect.Rate = 0
	else
		Character.ReverbSoundEffect.DecayTime = 3.8
		Character.ReverbSoundEffect.Density = 0.45
		Character.ReverbSoundEffect.Diffusion = 0.55
		Character.ReverbSoundEffect.DryLevel = -6
		Character.ReverbSoundEffect.WetLevel = -18
		Character.EqualizerSoundEffect.HighGain = 9.1
		Character.EqualizerSoundEffect.LowGain = -0.8
		Character.EqualizerSoundEffect.MidGain = 5.5
		Character.EqualizerSoundEffect.Priority = 9
		Character.ChorusSoundEffect.Depth = 0.58
		Character.ChorusSoundEffect.Mix = 0.06
		Character.ChorusSoundEffect.Priority = -1
		Character.ChorusSoundEffect.Rate = 0.8
	end
	Humanoid.HipHeight = 0
	Humanoid.Sit = false
	Humanoid.PlatformStand = ISFLYING
	Humanoid.UseJumpPower = true
	Humanoid.JumpPower = 50
	Humanoid.BreakJointsOnDeath = false
	Humanoid.DisplayDistanceType = "Subject"
	Humanoid.Name = Funcs.RandomString()
	Humanoid.RigType = "R6"
	Humanoid.AutoRotate = true
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead,false)
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics,false)
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming,false)
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying,false)
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp,false)
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown,false)
	usuckmongrio.HumanoidRootPart.CFrame = RootPart.CFrame
	if Torso.CFrame.Y >= 9999 and not alreadyfixing then
		Funcs.characterfixer()
		Funcs.soundfixer()
		Funcs.getup()
	elseif Torso.CFrame.Y <= workspace.FallenPartsDestroyHeight+5.7 and not alreadyfixing then
		Funcs.getback()
	elseif Torso.CFrame.X >= 9999 and not alreadyfixing then
		Funcs.characterfixer()
		Funcs.soundfixer()
		Funcs.getup()
	elseif Torso.CFrame.Z >= 9999 and not alreadyfixing then
		Funcs.characterfixer()
		Funcs.soundfixer()
		Funcs.getup()
	elseif Torso.CFrame.X <= -9999 and not alreadyfixing then
		Funcs.characterfixer()
		Funcs.soundfixer()
		Funcs.getup()
	elseif Torso.CFrame.Z <= -999 and not alreadyfixing then
		Funcs.characterfixer()
		Funcs.soundfixer()
		Funcs.getup()
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
		v:Stop()
	end
	SINE = SINE + 1
	sine = sine + 1
	ILThrottle,ILSine = (tick()-ILLastFrame)/(1/60),ILSine+(tick()-ILLastFrame)*60
	ILLastFrame = tick()
	Hue = Hue + 1
	if (Hue>360) then Hue = 0 end
	TORSOVELOCITY = (RootPart.Velocity).magnitude
	TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local sensitivity = 25
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
	local WALKSPEEDVALUE = 12 / (Humanoid.WalkSpeed / 16)
	local sidevec = math.clamp((Torso.Velocity*Torso.CFrame.rightVector).X+(Torso.Velocity*Torso.CFrame.rightVector).Z,-Humanoid.WalkSpeed,Humanoid.WalkSpeed)
	local forwardvec =  math.clamp((Torso.Velocity*Torso.CFrame.lookVector).X+(Torso.Velocity*Torso.CFrame.lookVector).Z,-Humanoid.WalkSpeed,Humanoid.WalkSpeed)
	local sidevelocity = sidevec/Humanoid.WalkSpeed
	local forwardvelocity = forwardvec/Humanoid.WalkSpeed
	local lhit,lpos = workspace:FindPartOnRayWithIgnoreList(Ray.new(LeftLeg.CFrame.p,((CFrame.new(LeftLeg.Position,LeftLeg.Position - Vector3.new(0,1,0))).lookVector).unit * (2)), {Effects,Character})
	local rhit,rpos = workspace:FindPartOnRayWithIgnoreList(Ray.new(RightLeg.CFrame.p,((CFrame.new(RightLeg.Position,RightLeg.Position - Vector3.new(0,1,0))).lookVector).unit * (2)), {Effects,Character})
	if mde == "Corrupt" then
		RootJoint.C1 = Clerp.IL(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
		Neck.C1 = Clerp.IL(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
		RightHip.C1 = Clerp.IL(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp.IL(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		if ATTACK == false then
			if TORSOVELOCITY < sensitivity/3.125 then
				ANIM = "Idle"
				DOUBLED = false
				READYTODOUBLE = false
				if TypeOfMode == "Godcat" then
					RootJoint.C0 = Clerp.IL(RootJoint.C0,ROOTC0 * CF(0, 0, -0.2+.15*math.sin(sine/32)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.15 / 1)
					Neck.C0 = Clerp.IL(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(40), RAD(-10), RAD(0)), 0.15 / 1)
					RightShoulder.C0 = Clerp.IL(RightShoulder.C0, CF(0.9, 0.3, -0.5) * ANGLES(RAD(85), RAD(20), RAD(-80+5*math.sin(sine/24))) * RIGHTSHOULDERC0, 0.15 / 1)
					LeftShoulder.C0 = Clerp.IL(LeftShoulder.C0, CF(-1.5, 0.1, 0) * ANGLES(RAD(-40), RAD(-90), RAD(-10-5*math.sin(sine/24))) * LEFTSHOULDERC0, 0.15 / 1)
					RightHip.C0 = Clerp.IL(RightHip.C0, CF(1, -0.8-.15*math.sin(sine/32), 0) * ANGLES(RAD(-10), RAD(90), RAD(0)) * ANGLES(RAD(-8+2.5*math.sin(sine/32)), RAD(0), RAD(0)), 0.15 / 1)
					LeftHip.C0 = Clerp.IL(LeftHip.C0, CF(-1, -0.8-.15*math.sin(sine/32), 0) * ANGLES(RAD(-20), RAD(-90), RAD(0)) * ANGLES(RAD(-8+2.5*math.sin(sine/32)), RAD(0), RAD(0)), 0.15 / 1)
					snap = math.random(1,72)
					if snap == 1 then	
						CreateSound(363808674,Head,3,1.3,false)
						Neck.C0 = Clerp.IL(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-sick.PlaybackLoudness/7,100000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-99999-sick.PlaybackLoudness/7,99999+sick.PlaybackLoudness/7)), RAD(MRANDOM(-200-sick.PlaybackLoudness/7,48375935+sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
					end
					Base.Transparency = 1
					NeonParts.Transparency = 1
				elseif TypeOfMode == "LC" then
					RootJoint.C0 = Clerp.LC(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),1,3 - .5 * math.sin(sine/50)),0.7/3)
					Neck.C0 = Clerp.LC(Neck.C0,NECKC0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
					RightShoulder.C0 = Clerp.LC(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
					LeftShoulder.C0 = Clerp.LC(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
					RightHip.C0 = Clerp.LC(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
					LeftHip.C0 = Clerp.LC(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
					GunJoint.C0 = Clerp.LC(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
					Base.Transparency = 0

					NeonParts.Transparency = 0	
				end	
			elseif TORSOVELOCITY >= sensitivity/3.125 then
				ANIM = "Walk"
				if TypeOfMode == "Godcat" then
					if Anim == "Walk" or TORSOVELOCITY >= sensitivity/3.125 then
						RootJoint.C1 = Clerp.LC(RootJoint.C1,rc0 * CFrame.new(0,0,0.1 + 0.05 * math.cos(sine / 6)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),2 / 3)
						Neck.C1 = Clerp.LC(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0) - Head.RotVelocity.Y / 30),0.2 / 3)
						RightHip.C1 = Clerp.LC(RightHip.C1,CFrame.new(0.5,.95-.2*math.sin(sine/6),-.15*math.sin(sine/6)) * CFrame.Angles(math.rad(-5),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-20+45 * math.cos(sine/6))),0.6 / 3)
						LeftHip.C1 = Clerp.LC(LeftHip.C1,CFrame.new(-0.5,.95+.2*math.sin(sine/6),.15*math.sin(sine/6)) * CFrame.Angles(math.rad(-5),math.rad(-90),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(20+45 * math.cos(sine/6))),0.6 / 3)
					elseif (Anim ~= "Walk") or (not TORSOVELOCITY >= sensitivity/3.125) then
						RootJoint.C1 = Clerp.LC(RootJoint.C1,rc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.2 / 3)
						Neck.C1 = Clerp.LC(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.2 / 3)
						RightHip.C1 = Clerp.LC(RightHip.C1,CFrame.new(0.5,1,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7 / 3)
						LeftHip.C1 = Clerp.LC(LeftHip.C1,CFrame.new(-0.5,1,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7 / 3)
					end
					local wsVal = 5
					RootJoint.C0 = Clerp.LC(RootJoint.C0,rc0 * CFrame.new(0,0,0 + 0.05 * math.cos(sine/6)) * CFrame.Angles(math.rad(20),math.rad(0 + 2.5 * math.cos(sine/6)),math.rad(0 - 2.5 * math.cos(sine/6))),1 / 3)
					Neck.C0 = Clerp.LC(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(-20 - 3 * math.cos(sine / 12)),math.rad(0 - 2.5 * math.cos(sine / 22)),math.rad(0 - 2.5 * math.cos(sine / 12))),1 / 3)
					RightShoulder.C0 = Clerp.LC(RightShoulder.C0,CFrame.new(1.5,0.5,0 + 0.2 * math.cos(sine/6)) * CFrame.Angles(math.rad(-20 + 45 * math.cos(sine/6)),math.rad(0 - 10 * math.cos(sine/6)),math.rad(0 + 2.5 * math.cos(sine/6))) * rscp,1 / 3)
					LeftShoulder.C0 = Clerp.LC(LeftShoulder.C0,CFrame.new(-1.5,0.5,0 - 0.2 * math.cos(sine/6)) * CFrame.Angles(math.rad(20 - 45 * math.cos(sine/6)),math.rad(0 - 10 * math.cos(sine/6)),math.rad(0 + 2.5 * math.cos(sine/6))) * lscp,1 / 3)
					RightHip.C0 = Clerp.LC(RightHip.C0,CFrame.new(1 ,-1,0) * CFrame.Angles(math.rad(0),math.rad(85),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1 / 3)
					LeftHip.C0 = Clerp.LC(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(0),math.rad(-85),math.rad(0)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1 / 3)
				elseif TypeOfMode == "LC" then
					RootJoint.C0 = Clerp.LC(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,4 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(40),math.rad(0),math.rad(0)),.7/3)
					Neck.C0 = Clerp.LC(Neck.C0,NECKC0 * CFrame.new(0,-.25,0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),.7/3)
					RightShoulder.C0 = Clerp.LC(RightShoulder.C0,CFrame.new(1.5,.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(5 + 2 * math.cos(sine/19))) * RIGHTSHOULDERC0,.7/3)
					LeftShoulder.C0 = Clerp.LC(LeftShoulder.C0,CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(-5 - 2 * math.cos(sine/19))) * LEFTSHOULDERC0,.7/3)
					RightHip.C0 = Clerp.LC(RightHip.C0,CFrame.new(1,-.5,-.5) * CFrame.Angles(math.rad(-20 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),.7/3)
					LeftHip.C0 = Clerp.LC(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-20 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),.7/3)
					GunJoint.C0 = Clerp.LC(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)
				end	
			end
		end
	end
	if mde == "Relaxed" then
		RootJoint.C1 = Clerp.OG(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
		Neck.C1 = Clerp.OG(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
		RightHip.C1 = Clerp.OG(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp.OG(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		if ATTACK == false then
			if TORSOVELOCITY < sensitivity/3.125 then
				ANIM = "Idle"
				DOUBLED = false
				READYTODOUBLE = false
				RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(-90 + 4 * math.sin(sine/100)),math.rad(0),math.rad(0)),1)
				Neck.C0 = Clerp.OG(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20),math.rad(10*math.cos(sine/100)),math.rad(0)),1)
				RightShoulder.C0 = Clerp.OG(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-160.6-10*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,1)
				LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-160+10*math.sin(sine/50)),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,1)
				RightHip.C0 = Clerp.OG(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(80),math.rad(5+10*math.sin(sine/45))),1)
				LeftHip.C0 = Clerp.OG(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-30),math.rad(-80),math.rad(-5-10*math.sin(sine/45))),1)
			elseif TORSOVELOCITY >= sensitivity/3.125 then
				ANIM = "Walk"
				RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 + .25*Cos(sine/63)+.92*Sin(sine/95), 0, 1 + 1 * SIN(SINE / 53)) * ANGLES(RAD(70), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), 0.15 / Animation_Speed)
				Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12 + 4.10 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -.5 - 0.02 * SIN(SINE / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(SINE / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(SINE / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(SINE / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			end
			Base.Transparency = 1

			NeonParts.Transparency = 1
		end
	end
	if mde == "Undesired" then
		RootJoint.C1 = Clerp.OG(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
		Neck.C1 = Clerp.OG(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
		RightHip.C1 = Clerp.OG(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp.OG(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		if ATTACK == false then
			if TORSOVELOCITY < sensitivity/3.125 then
				ANIM = "Idle"
				DOUBLED = false
				READYTODOUBLE = false
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp.OG(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				if math.random(1,8) == 1 then
					Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
				end
				if(math.random(1,4)==1)then
					RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				end	
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp.OG(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end
				if(math.random(1,4)==1)then
					RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
					LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				end	
				if math.random(1,25) == 1 then
					Neck.C0 = Clerp.OG(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))),1.5/Animation_Speed)
				end	
				snap = math.random(1,32)
				if snap == 1 then
					Neck.C0 = Clerp.OG(Neck.C0,NECKC0*cf(0,0,0+((1)-1))*angles(math.rad(math.random(-12093487,10000)),math.rad(math.random(-200,10000)),math.rad(math.random(-999999999,10000))),1/Animation_Speed)
				end
				if MRANDOM(1,10) == 1 then
					Neck.C0=Clerp.OG(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
				end	
				local bouncyboi = sick.PlaybackLoudness / 1200
				RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.2 * SIN(SINE / 12)) * ANGLES(RAD(0+5*COS(sine/12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5 - .1*COS(sine / 16), 0) * ANGLES(RAD(0), RAD(0), RAD(10 - 7.5*Cos(sine/32))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5 - .1 * COS(sine / 16), 0) * ANGLES(RAD(0), RAD(0), RAD(-10 + 7.5*Cos(sine/32))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1- 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1- 0.2 * COS(SINE / 12) , 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
				snap = math.random(1,72)
				if snap == 1 then
					CreateSound(363808674,Head,3,1.3,false)
					Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-sick.PlaybackLoudness/7,100000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-99999-sick.PlaybackLoudness/7,99999+sick.PlaybackLoudness/7)), RAD(MRANDOM(-200-sick.PlaybackLoudness/7,48375935+sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
				end 
				if MRANDOM(1,20+sick.PlaybackLoudness/7) == 1 then
					RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90-sick.PlaybackLoudness/7,90+sick.PlaybackLoudness/7)), RAD(MRANDOM(-30-sick.PlaybackLoudness/7,30+sick.PlaybackLoudness/7)), RAD(MRANDOM(-50-sick.PlaybackLoudness/7,50+sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000-sick.PlaybackLoudness/7,10000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-900-sick.PlaybackLoudness/7,900+sick.PlaybackLoudness/7)), RAD(MRANDOM(-20-sick.PlaybackLoudness/7,20+sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
				end		   
				if MRANDOM(1, 10) == 1 then
					Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)
				end
			elseif TORSOVELOCITY >= sensitivity/3.125 then
				ANIM = "Walk"
				RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 + .25*Cos(sine/63)+.92*Sin(sine/95), 0, 1 + 1 * SIN(SINE / 53)) * ANGLES(RAD(70), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), 0.15 / Animation_Speed)
				Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12 + 4.10 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -.5 - 0.02 * SIN(SINE / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(SINE / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(SINE / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(SINE / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			end
			Base.Transparency = 1

			NeonParts.Transparency = 1
		end
	end
	if mde == "LCV2Mode5" then
		Humanoid.HipHeight = 0
		Base.Transparency = 0

		NeonParts.Transparency = 0
		Humanoid.WalkSpeed = 16
		if not ATTACK then
			if TORSOVELOCITY < sensitivity/3.125 then
				Anim = "Idle"
				RootJoint.C0 = Clerp.IL(RootJoint.C0,ROOTC0*CFrame.new(0,0,.05*math.cos(ILSine/12))*CFrame.Angles(math.rad(15),0,0),.25)
				Neck.C0 = Clerp.IL(Neck.C0,NECKC0*CFrame.Angles(math.rad(-15-3*math.cos(ILSine/12)),math.rad(5-5*math.sin(ILSine/12)),0),.25)
				RightShoulder.C0 = Clerp.IL(RightShoulder.C0,CFrame.new(1.5,.5+0.1*math.cos(ILSine/12),0)*CFrame.Angles(math.rad(-53.75+1.75*math.cos(ILSine/12)),0,math.rad(5))*RIGHTSHOULDERC0,.25)
				LeftShoulder.C0 = Clerp.IL(LeftShoulder.C0,CFrame.new(-1.5,.5+.1*math.sin(ILSine/12),0)*CFrame.Angles(math.rad(15),0,math.rad(-5+5*math.cos(ILSine/12)))*LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp.IL(RightHip.C0,CFrame.new(1,-1-.05*math.cos(ILSine/12),-.01)*CFrame.Angles(math.rad(10),math.rad(80),math.rad(0)),.25)
				LeftHip.C0 = Clerp.IL(LeftHip.C0,CFrame.new(-1,-1-.05*math.cos(ILSine/12),-.01)*CFrame.Angles(math.rad(20),math.rad(-80),math.rad(0)),.25)
				GunJoint.C0 = Clerp.IL(GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-106.3-.9*math.cos(ILSine/12)),0,0),.25)
			elseif TORSOVELOCITY >= sensitivity/3.125 then
				Anim = "Walk"
				RootJoint.C0 = Clerp.IL(RootJoint.C0,ROOTC0*CFrame.new(0,.125*math.sin(ILSine/12),0)*CFrame.Angles(math.rad(10-5*math.cos(ILSine/12)),math.rad(-10*math.cos(ILSine/12)),math.rad(-5*math.cos(ILSine/12))),.25)
				Neck.C0 = Clerp.IL(Neck.C0,NECKC0*CFrame.Angles(math.rad(10-5*math.cos(ILSine/12)),math.rad(10*math.cos(ILSine/12)),math.rad(5*math.cos(ILSine/12))),.25)
				RightShoulder.C0 = Clerp.IL(RightShoulder.C0,CFrame.new(1.5,.5+.2*math.sin(ILSine/12),-.25)*CFrame.Angles(math.rad(165-15*math.cos(ILSine/12)),math.rad(-10+5*math.sin(ILSine/12)),math.rad(10))*RIGHTSHOULDERC0,.25)
				LeftShoulder.C0 = Clerp.IL(LeftShoulder.C0,CFrame.new(-1.5,.5-.15*math.cos(ILSine/12),.5*math.sin(ILSine/12))*CFrame.Angles(math.rad(-30*math.sin(ILSine/12)),math.rad(5*math.cos(ILSine/12)),0)*LEFTSHOULDERC0,.25)
				RightHip.C0 = Clerp.IL(RightHip.C0,CFrame.new(1,-.9-.2*math.cos(ILSine/12),.5*math.sin(ILSine/12))*CFrame.Angles(math.rad(-10-40*math.sin(ILSine/12)),math.rad(90+5*math.cos(ILSine/12)),math.rad(2.5*math.cos(ILSine/12))),.25)
				LeftHip.C0 = Clerp.IL(LeftHip.C0,CFrame.new(-1,-.9+.2*math.cos(ILSine/12),-.5*math.sin(ILSine/12))*CFrame.Angles(math.rad(-10+40*math.sin(ILSine/12)),math.rad(-90+5*math.cos(ILSine/12)),math.rad(2.5*math.cos(ILSine/12))),.25)
				GunJoint.C0 = Clerp.IL(GunJoint.C0,CFrame.new(.05,-1,-.15)*CFrame.Angles(math.rad(-90),0,0),.25)
			end
		end
	end
	if mde == "Echo" then
		RootJoint.C1 = Clerp.LC(RootJoint.C1,ROOTC0,.2/3)
		Neck.C1 = Clerp.LC(Neck.C1,CFrame.new(0,-.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),.2/3)
		RightHip.C1 = Clerp.LC(RightHip.C1,CFrame.new(.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp.LC(LeftHip.C1,CFrame.new(-.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		RightShoulder.C1 = Clerp.LC(RightShoulder.C1,CFrame.new(-.5,.5,0,0,0,1,0,1,-0,-1,0,0),1)
		LeftShoulder.C1 = Clerp.LC(LeftShoulder.C1,CFrame.new(.5,.499975681,0,0,0,-1,0,1,0,1,0,0),1)
		Humanoid.HipHeight = 0
		if ATTACK == false then
			if TORSOVELOCITY < sensitivity/3.125 then
				Anim = "Idle"
				DOUBLED = false
				READYTODOUBLE = false
				RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, -0.03 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 1 / 5)
				Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(SINE / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / 5)
				if math.random(1,5) == 1 then
					Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)	
				end
				RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(180), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / 5)
				LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.15 / 5)
				RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(95), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / 5)
				LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-55), RAD(0)) * ANGLES(RAD(-12), RAD(0), RAD(0)), 1 / 5)
				GunJoint.C0 = Clerp.OG(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)

			elseif TORSOVELOCITY >= sensitivity/3.125 then
				Anim = "Walk"
				DOUBLED = false
				READYTODOUBLE = false
				RootJoint.C0 = Clerp.OG(RootJoint.C0, ROOTC0 * CF(0* 1, 0* 1, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7* 1) * ANGLES(RAD(26 - 4.5 * COS(SINE / 3.5)), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(15 * COS(SINE / 7))), 0.15)
				Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(SINE / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / Animation_Speed)
				if math.random(1,5) == 1 then
					Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)	
				end
				RightHip.C0 = Clerp.OG(RightHip.C0, CF(1* 1, -0.925 - 0.5 * COS(SINE / 7) / 2* 1, 0.7 * COS(SINE / 7) / 2* 1) * ANGLES(RAD(-15 - 55 * COS(SINE / 7)) - RightLeg.RotVelocity.Y / 75 + -SIN(SINE / 7) / 2.5, RAD(90 - 0.1 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 0.1 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1* 1, -0.925 + 0.5 * COS(SINE / 7) / 2* 1, -0.7 * COS(SINE / 7) / 2* 1) * ANGLES(RAD(-15 + 55 * COS(SINE / 7)) + LeftLeg.RotVelocity.Y / 75 + SIN(SINE / 7) / 2.5, RAD(-90 - 0.1 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 0.1 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
				RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(180), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / 5)
				LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(SINE / 30)* 1, -0.34 * COS(SINE / 7* 1)) * ANGLES(RAD(-110)  * COS(SINE / 7) , RAD(-90) ,	RAD(-13) + LeftArm.RotVelocity.Y / 75), 0.15)
				GunJoint.C0 = Clerp.OG(GunJoint.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1/2)

			end
			Base.Transparency = 0

			NeonParts.Transparency = 0
		end
	end
	if mde == "Vis" then
		RootJoint.C1 = Clerp.OG(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
		Neck.C1 = Clerp.OG(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
		RightHip.C1 = Clerp.OG(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp.OG(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		if ATTACK == false then
			if TORSOVELOCITY < sensitivity/3.125 then
				ANIM = "Idle"
				DOUBLED = false
				READYTODOUBLE = false
				if TypeOfMode == "Godcat" then
					WACKYEFFECT({Time = 2.5, EffectType = "Sphere", Size = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/850,0,0+170*sick.PlaybackLoudness/850), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15+(sick.PlaybackLoudness)/-19 - 2.5 * SIN(SINE / 15)), RAD(0), RAD(-25)), 3 / Animation_Speed)
					RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(40+(sick.PlaybackLoudness)/7.5), RAD(0), RAD(37)) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
					RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.8 / Animation_Speed)
					LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-26+5*COS(SINE/15))) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
					RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
					LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
				elseif TypeOfMode == "LC" then
					Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-25)), 3 / Animation_Speed)
					RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.6, 0.35, 0.4) * ANGLES(RAD(55 - 0 * math.cos(sine/15) + sick.PlaybackLoudness/4.5), RAD(0), RAD(20)) * ANGLES(RAD(0 - 1.5 *  math.cos(sine/15) + 2.5 * math.sin(sine/12)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / 1)
					RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 - 0.05 * math.cos(sine/15) + 0.05 * math.sin(sine/15), 0, 0 + 0.05 * math.cos(sine/20)) * ANGLES(RAD(0), RAD(5), RAD(10)), 0.8 / 1)
					LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.4, 0.35, 0.4) * ANGLES(RAD(15), RAD(40), RAD(12)) * ANGLES(RAD(0 - 1.5 * math.cos(sine/15) + 2.5 * math.sin(sine/12)), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.15 / 1)
					RightHip.C0 = Clerp.OG(RightHip.C0, CF(1 - 0.05 * math.cos(sine/15) + 0.05 * math.sin(sine/15), -1 - 0.05 * math.cos(sine/20), -0.01) * ANGLES(RAD(0), RAD(83), RAD(-5)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / 1)
					LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1 - 0.05 * math.cos(sine/15) + 0.05 * math.sin(sine/15), -1 - 0.05 * math.cos(sine/20), 0) * ANGLES(RAD(0), RAD(-75), RAD(5)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / 1)
					WACKYEFFECT({Time = 30, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,6,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(3,7)) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1,1)*5, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					WACKYEFFECT({Time = MRANDOM(15,65) ,EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					if MRANDOM(1,1) == 1 then
						WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(7+sick.PlaybackLoudness/25,0.55,7+sick.PlaybackLoudness/25), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = RightArm.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
						WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(2,2,2), Transparency = 0.3, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = RightArm.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
					end
				end	
			elseif TORSOVELOCITY >= sensitivity/3.125 then
				ANIM = "Walk"
				RootJoint.C0 = Clerp.OG(RootJoint.C0,ROOTC0 * CF(0 + .25*Cos(sine/63)+.92*Sin(sine/95), 0, 1 + 1 * SIN(SINE / 53)) * ANGLES(RAD(70), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), 0.15 / Animation_Speed)
				Neck.C0 = Clerp.OG(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp.OG(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp.OG(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12 + 4.10 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp.OG(RightHip.C0, CF(1, -.5 - 0.02 * SIN(SINE / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(SINE / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp.OG(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(SINE / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(SINE / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
			end
			Base.Transparency = 1

			NeonParts.Transparency = 1
		end
	end
	if mde == "Sit" then
		RootJoint.C1 = Clerp.OG(RootJoint.C1,ROOTC0 * CFrame.new(0,0,0),0.2/3)
		Neck.C1 = Clerp.OG(Neck.C1,CFrame.new(0,-0.5,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180)),0.2/3)
		RightHip.C1 = Clerp.OG(RightHip.C1,CFrame.new(0.5,1,0,-4.37113918e-08,0,1,0,1,0,-1,0,-4.37113918e-08),1)
		LeftHip.C1 = Clerp.OG(LeftHip.C1,CFrame.new(-0.5,1,0,-4.37113918e-08,-0,-1,0,1,-0,1,0,-4.37113918e-08),1)
		if ATTACK == false then
			if TORSOVELOCITY < sensitivity/3.125 then
				ANIM = "Idle"
				DOUBLED = false
				READYTODOUBLE = false
				local Alpha = .3
				RootJoint.C0 = RootJoint.C0:lerp(cf(0.1,-0.3 + sick.PlaybackLoudness/1000,0)*angles(math.rad(-2.2),math.rad(-2.8),math.rad(-14.2 * math.cos(sine/10)))*ROOTC0,Alpha)
				LeftHip.C0 = LeftHip.C0:lerp(cf(-0.9,-0.8-sick.PlaybackLoudness/1000,-0.2)*angles(math.rad(-10),math.rad(0),math.rad(-4.6+14.2 * math.cos(sine/10)))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
				RightHip.C0 = RightHip.C0:lerp(cf(1,-0.7-sick.PlaybackLoudness/1000,-0.2)*angles(math.rad(-13.3),math.rad(0),math.rad(10.4+14.2 * math.cos(sine/10)))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
				LeftShoulder.C0 = LeftShoulder.C0:lerp(cf(-1.4,0.3,0.2)*angles(math.rad(40 + sick.PlaybackLoudness/5),math.rad(26 * math.cos(sine/10)),math.rad(-14.1)),Alpha)
				RightShoulder.C0 = RightShoulder.C0:lerp(cf(1.5,0.4,0.1)*angles(math.rad(40 +sick.PlaybackLoudness/5),math.rad(-16.8 * math.cos(sine/10)),math.rad(10.5)),Alpha)
				Neck.C0 = Neck.C0:lerp(cf(0.3 * math.cos(sine/10),0,0.2)*angles(math.rad(-9.8),math.rad(0),math.rad(14.5 * math.cos(sine/10)))*NECKC0,Alpha)
			elseif TORSOVELOCITY >= sensitivity/3.125 then
				ANIM = "Walk"
				local Alpha = .3
				RootJoint.C0 = RootJoint.C0:lerp(cf(0.1,-0.3 + sick.PlaybackLoudness/1000,0)*angles(math.rad(-2.2),math.rad(-2.8),math.rad(-14.2 * math.cos(sine/10)))*ROOTC0,Alpha)
				LeftHip.C0 = LeftHip.C0:lerp(cf(-0.9,-0.8-sick.PlaybackLoudness/1000,-0.2)*angles(math.rad(-10),math.rad(0),math.rad(-4.6+14.2 * math.cos(sine/10)))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
				RightHip.C0 = RightHip.C0:lerp(cf(1,-0.7-sick.PlaybackLoudness/1000,-0.2)*angles(math.rad(-13.3),math.rad(0),math.rad(10.4+14.2 * math.cos(sine/10)))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
				LeftShoulder.C0 = LeftShoulder.C0:lerp(cf(-1.4,0.3,0.2)*angles(math.rad(40 + sick.PlaybackLoudness/5),math.rad(26 * math.cos(sine/10)),math.rad(-14.1)),Alpha)
				RightShoulder.C0 = RightShoulder.C0:lerp(cf(1.5,0.4,0.1)*angles(math.rad(40 +sick.PlaybackLoudness/5),math.rad(-16.8 * math.cos(sine/10)),math.rad(10.5)),Alpha)
				Neck.C0 = Neck.C0:lerp(cf(0.3 * math.cos(sine/10),0,0.2)*angles(math.rad(-9.8),math.rad(0),math.rad(14.5 * math.cos(sine/10)))*NECKC0,Alpha)
			end
			Base.Transparency = 1

			NeonParts.Transparency = 1
		end
	end
	if not Character:FindFirstChildOfClass("Humanoid") and not alreadyfixing then
		Funcs.characterfixer()
	end
	for i,g in pairs(Character:GetDescendants()) do 
		if g:IsA("BasePart") then
			if g.LocalTransparencyModifier ~= 0 and not alreadyfixing then
				Funcs.characterfixer()	
			end
		end
	end
	unanchor()
	Humanoid.MaxHealth = "inf"
	Humanoid.Health = "inf"
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	eeeblock.CFrame = Torso.CFrame
end
--//=================================\\
--\\=================================//
